<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Atcoder Beginner Contest 368 题解</title>
    <url>/2024-08-24-atcoder-abc-368.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,3378th,Solved ABCD,+5</p>
<span id="more"></span>


<h1 id="A-Cut"><a href="#A-Cut" class="headerlink" title="A.Cut"></a>A.Cut</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $ 和一个数字 $k $ ，输出 $a[k],a[k+1],…,a[n],a[1],a[2],…a[k-1]$。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>直接 for 循环输出即可</li>
<li>使用 STL  <code>deque</code> （？）</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// deque</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, tmp;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        deq.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        deq.<span class="built_in">push_front</span>(deq.<span class="built_in">back</span>());</span><br><span class="line">        deq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!deq.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; deq.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>, deq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// for</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - k; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Decrease-2-max-elements"><a href="#B-Decrease-2-max-elements" class="headerlink" title="B.Decrease 2 max elements"></a>B.Decrease 2 max elements</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $，重复将数组降序排序，将前两个数字分别 -1，求几次后让整个数组最多只有一个正数</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="针对此题"><a href="#针对此题" class="headerlink" title="针对此题"></a>针对此题</h3><p>范围非常小，直接暴力就行。</p>
<h3 id="范围变大时候的更快解法"><a href="#范围变大时候的更快解法" class="headerlink" title="范围变大时候的更快解法"></a>范围变大时候的更快解法</h3><p>首先，每次操作 $\displaystyle\sum _ {i&#x3D;1} ^ NA _ i$ 都会减少 $2$ ，因此答案小于或等于 $\displaystyle\Biggl\lfloor\dfrac12\sum _ {i&#x3D;1} ^ NA _ i\Biggr\rfloor$ 。</p>
<p>接下来，由于每次操作中 $\displaystyle\max _ {1\leq i\leq N}A _ i$ 最多减少 $1$ ，因此 $\displaystyle\sum _ {i&#x3D;1} ^ NA _ i-\max _ {1\leq i\leq N}A _ i$ 在 $1$ 操作中减少 $1$ 或 $2$ ，结果小于或等于 $\displaystyle\sum _ {i&#x3D;1} ^ NA _ i-\max _ {1\leq i\leq N}A _ i$ 。</p>
<p>所以答案为$\displaystyle\min\Biggl\lbrace\Biggl\lfloor\dfrac12\sum _ {i&#x3D;1} ^ NA _ i\Biggr\rfloor,\sum _ {i&#x3D;1} ^ NA _ i-\max _ {1\leq i\leq N}A _ i\Biggr\rbrace$。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// brute</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; vec[i];</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(vec), greater&lt;&gt;());</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		vec[<span class="number">0</span>]--, vec[<span class="number">1</span>]--, cnt++;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(vec), greater&lt;&gt;());</span><br><span class="line">	&#125; <span class="keyword">while</span> (vec[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; vec[<span class="number">1</span>] &gt; <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// math</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		sum += a;</span><br><span class="line">		mx = <span class="built_in">max</span>(a, mx);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(sum / <span class="number">2</span>, sum - mx) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Triple-Attack"><a href="#C-Triple-Attack" class="headerlink" title="C.Triple Attack"></a>C.Triple Attack</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $，每次对数组第一个数重复以下操作，当第一个数降到0及以下的时候将其移出数组：</p>
<ol>
<li>将数字减少1</li>
<li>将数字减少1</li>
<li>将数字减少3</li>
</ol>
<p>问几次操作后能置空整个数组。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>本题有坑。移出一个数字以后其操作次数是保留的，如果在移出头部数字的时候已经进行了前两步操作，那么可以直接对下一个数进行第三步操作。（吃了两发）</p>
<p>当第一个敌人的生命值达到 $5$ 或更高时，接下来的 $3$ 操作可以使第一个敌人的生命值减少 $5$ ，无论 $T$ 的当前值是多少。如果第一个敌人的生命值是 $H$ ，这组三个动作将重复 $\lfloor\frac{H}{5}\rfloor$ 组。通过一次性处理这部分并模拟即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	i64 cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		cnt += a / <span class="number">5</span> * <span class="number">3</span>;</span><br><span class="line">		a %= <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">while</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">				a -= <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				a--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Minimum-Steiner-Tree"><a href="#D-Minimum-Steiner-Tree" class="headerlink" title="D.Minimum Steiner Tree"></a>D.Minimum Steiner Tree</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一颗 $n$ 个节点， $n-1$ 条边的树，给出 $k$ 个节点，找到连接这 $k$ 个节点的最小联通块的大小。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>带路径染色的DFS。用 <code>vector &lt;bool&gt;</code> 存一下被染色的路径点和需要找到的 $k$ 个节点即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[start] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> edge : edges[start])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[edge] &amp;&amp; <span class="built_in">dfs</span>(edge))</span><br><span class="line">			vec[start] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[start] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (vec[start])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		edges[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		edges[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">			start = tmp;</span><br><span class="line">		vec[tmp] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(start);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count</span>(<span class="built_in">all</span>(vec), <span class="literal">true</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分</strong></p>
<h1 id="F-Dividing-Game"><a href="#F-Dividing-Game" class="headerlink" title="F.Dividing Game"></a>F.Dividing Game</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $，<code>Anna</code> 和 <code>Bruno</code> 轮流选取其中的数字 $a[i]$ ，并且将 $a[i]$ 替换为其任意一个非自己的因数。不能进行此操作的玩家输掉比赛。问谁会赢。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>Nim 游戏中的 SG 函数。<a href="https://oi.wiki/math/game-theory/impartial-game/#%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F%E4%B8%8E-sg-%E5%87%BD%E6%95%B0">参考资料（OI WIKI）</a>，<a href="https://www.luogu.com.cn/article/shyocttb">参考资料2（洛谷博客，SG函数精讲）</a>。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="type">int</span> m = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a[i], m = <span class="built_in">max</span>(m, a[i]);</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">d</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= m; j += i)</span><br><span class="line">			d[j].<span class="built_in">push_back</span>(i); <span class="comment">// 因数</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sg</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= m; x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k = d[x].<span class="built_in">size</span>();</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y : d[x])</span><br><span class="line">			<span class="keyword">if</span> (sg[y] &lt;= k)</span><br><span class="line">				cnt[sg[y]]++;</span><br><span class="line">		<span class="keyword">while</span> (cnt[sg[x]] &gt; <span class="number">0</span>)</span><br><span class="line">			sg[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		ans ^= sg[a[i]];</span><br><span class="line">	cout &lt;&lt; (ans &gt; <span class="number">0</span> ? <span class="string">&quot;Anna&quot;</span> : <span class="string">&quot;Bruno&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Add-and-Multiply-Queries"><a href="#G-Add-and-Multiply-Queries" class="headerlink" title="G.Add and Multiply Queries"></a>G.Add and Multiply Queries</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入两个数组 $ a[1],a[2],…,a[n] 和 b[1],b[2],…,b[n] $，给定 $q$ 组如下格式的询问：</p>
<p><code>1 i x</code>：将 $a[i]$ 的值改为 $x$。</p>
<p><code>2 i x</code>：将 $b[i]$ 的值改为 $x$。</p>
<p><code>3 l r</code>： 设定 $v&#x3D;0$，对于区间 $[l,r]$ ，将 $v$ 替换为 $v+a[i]$ 或者 $v*b[i]$，求最大的 $v$。</p>
<p><strong>保证操作3的答案最高为$10^{18}$。</strong></p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>因为保证了操作3有答案上限，则数组 $b$ 中超过 $1$ 的个数不会大于 $60$ 个 ($2^{60} &gt; 10^{18}$)。</p>
<p>用树状数组维护 $a$，用 $set$ 维护 $b[i] &gt; 1$ 的 $i$。然后查找区间内有没有大于 $1$ 的数，并且判断两种操作哪种最优即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	vector&lt;i64&gt; tr;</span><br><span class="line">	<span class="built_in">Fenwick</span>(vector&lt;i64&gt; &amp;vec)</span><br><span class="line">	&#123;</span><br><span class="line">		n = vec.<span class="built_in">size</span>();</span><br><span class="line">		tr.<span class="built_in">resize</span>(N);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">update_add</span>(i, vec[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update_add</span><span class="params">(<span class="type">int</span> x, i64 val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">			tr[i] += val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update_sub</span><span class="params">(<span class="type">int</span> x, i64 val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">update_add</span>(x, -val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		i64 res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">			res += tr[i];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;i64&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="function">Fenwick <span class="title">tree</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; b[i];</span><br><span class="line">		<span class="keyword">if</span> (b[i] &gt; <span class="number">1</span>)</span><br><span class="line">			st.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> op, l, r;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tree.<span class="built_in">update_sub</span>(l, a[l]);</span><br><span class="line">			a[l] = r;</span><br><span class="line">			tree.<span class="built_in">update_add</span>(l, a[l]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (b[l] &gt; <span class="number">1</span>)</span><br><span class="line">				st.<span class="built_in">erase</span>(l);</span><br><span class="line">			b[l] = r;</span><br><span class="line">			<span class="keyword">if</span> (b[l] &gt; <span class="number">1</span>)</span><br><span class="line">				st.<span class="built_in">insert</span>(l);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i64 v = a[l];</span><br><span class="line">			l = l + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> it = st.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">				<span class="keyword">if</span> (it == st.<span class="built_in">end</span>() || *it &gt; r)</span><br><span class="line">				&#123;</span><br><span class="line">					v += tree.<span class="built_in">query</span>(r) - tree.<span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				v += tree.<span class="built_in">query</span>(*it - <span class="number">1</span>) - tree.<span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">				v = <span class="built_in">max</span>(v * b[*it], v + a[*it]);</span><br><span class="line">				l = *it + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Train-Delay"><a href="#E-Train-Delay" class="headerlink" title="E.Train Delay"></a>E.Train Delay</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>$n$ 个城市，$m$ 条火车，第 $i$ 条 从 $a[i]$ 城市在 $s[i]$ 时刻出发，到达 $b[i]$ 城市的时刻为 $t[i]$。</p>
<p>现在第一条线路的火车晚点了 $x[1]$ 分钟，为了让任意一组本来可以换乘的火车仍能换乘，需要对其他的所有火车进行晚点（也可以不晚点）。<br>找出从第 $2$ 辆到第 $m$ 辆火车，每辆火车最少需要晚点多长时间。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p><code>I don&#39;t know how to write dp I am dp 低手</code>。</p>
<p>以下代码是 <code>jiangly</code> 的。大概思路还要梳理一下。可以参考一下Atcoder Editorial的思路。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> N, M, X0;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M &gt;&gt; X0;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(M)</span>, <span class="title">B</span><span class="params">(M)</span>, <span class="title">S</span><span class="params">(M)</span>, <span class="title">T</span><span class="params">(M)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; A[i] &gt;&gt; B[i] &gt;&gt; S[i] &gt;&gt; T[i];</span><br><span class="line">		A[i]--, B[i]--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">e</span>(<span class="number">2</span> * M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		e[<span class="number">2</span> * i] = &#123;S[i], <span class="number">1</span>, i&#125;;</span><br><span class="line">		e[<span class="number">2</span> * i + <span class="number">1</span>] = &#123;T[i], <span class="number">0</span>, i&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(M)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tm</span><span class="params">(N)</span></span>;</span><br><span class="line">	X[<span class="number">0</span>] = X0;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [t, o, i] : e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">1</span>)</span><br><span class="line">			X[i] = <span class="built_in">max</span>(X[i], tm[A[i]] - S[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tm[B[i]] = <span class="built_in">max</span>(tm[B[i]], T[i] + X[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">		cout &lt;&lt; X[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2024ACM集训队第二次入队赛 验题人题解</title>
    <url>/2024-09-22-2024-newbie-2-coord-tutorial.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码无效，请重试。" data-whm="解密内容无法验证其正确性，但你仍然可以查看。">
  <script id="hbeData" type="hbeData" data-hmacdigest="d46ad63218adb84ff1d88f1bb6389cff6e650c591968ac154b0877857f0ea595">4259d4bc7d60d6ea5a9caa8a37f4458b60535efe88ac59e81f9cb1438f36d21d8fcd9661f5d4b4f264d02552f7e4aaf22f37784eb3229478ca5450eb9ddc75bf806bbf9977aef181411f4999a24f6bbe5a5285569c946ab2bd503878cd46b18369b87b915c733ab2d6dcd04da88a4e115040408067b17dc8972849a9498f27c81c02f53ee856fd6dd811e029478c1cce9cb6a27bc0888f7ec8604f473977b4bddfed36c28d9db1a71123913239cf565ae5a1146c207a558d9f5eca6624b0b77ee72c84ca5092557b091f1bc45f87fbfb1776cfd023bc2040d9c1523b741e1ca6fb1614d0c3d49c4c584cf8a53545d22b16f3f5fd8bbc9e9c2e804472537c69eca59e2710fb78a4d625459c9ad3b21d5132a63411973d341f4235aa092c5b674835f099c46ab9ad53fbb6ca7f724a0b133a4620310ba530142180fd286cc34f28f41014fbb18a96fd1d8602fc02117aa57ffd16edde4ff20b526e866f840ceb8aa2636ceae84e5ce4b4b15afa2a2fd0995b304ca2acb1294ac8a7d8754cfbce06336e39b6ea65d7760dc95bb0df5f5ce272f990a34ed23f345fd0afbf42d3d83c1dbd82fb967671e5d313985d9a9f92a596bad304811b6fa38bf87589a2fc49e2bb6141539fc22902769723d0a744c1bb5aabe0ad2ee049d247cdcae11b4f56f2b02915a048e11866abfade9c6e053d9c0eb0aed049e8d24d402b98252234b32bbdbf68389ff7b2c777b34648f461f88d50e75376769bd772fc9b700821acd49febe6b75c3358cf27c32392eafcbef3916a0339a43b1e026b67068cecb1d53c453a26aa62524d6abce1f0d2c1b2db46f3655023c3f8492bd2d7fe0319022e726ad47e74f2ec638fa49047a47472403a0b80c9ecc4728d39217d0f711d17b35180efe8d22b592392d8fe407d7acc4aea518453d7fe663ba67aef243fe175ed9f1bf6bc8d2254f622a68d54b6df826b7138b68fc1d98d57a6a546e426d99d6d3e83108937f2cdecca6200fc0c48e1342e36e420646b4664de85d0dd81b10104339299dc526617a4bb6556c8fb6e286e5d05239ab1059e4c221d9e93d3db2d081cf149e0268c76307979d33db5a85b0349667414296d5dfebbf554426a3bd32d4b1737c33b1d6b586a0544a24d17bd497ecec5c294942bcd8a2be7d999b24801968c068349ad6d9f0f1f310459245809cb22363d351a84716184cdcbfb2e41e96cc4736580d29606b76c6a62b113793948e2ebcb48e13f6481ec3684858df5550b73d9f7af957d8383fb43900dcfc4253f46965b4c69202c2b83b48b7fa321e267330d12759ccf16fcf1b4467dc69298306349938258ff8d8cfdb90aadb28171138afd0df284f360dd911a4f492aee263388db3587b77a5261d30fab5c4a665e1e08bdcc666753f83180b2b40f7f29df24919adddfd1092975fadc8a02028f3117935dbf4117d54032f3c1f7521bf43ecec175749e4eb1fb655e02b9e5c23be72a9c1610937b3dbafdc7581037d571a45ba2b8fde5fde3bf165e9b7d33c4085984165f8391c91837d45418cdfbbc3ca10e6237c5bd7238804b0ec0f675cf2707980661c3f7e91fd3cb6a88f3a8481fbf6b4b83e8acfe15affd81fc7e3b713d8c5b5ea94ad06eaa4d85311ab1fadb48461d695f4ebd7eb5d0fb72ad34864a0541b967a1021ae4a5e4cb2619aa20552c58189de2338cffd613674c775f578c7ac671153fee972cdc489a90a46581ac6df4d787a440832bfaedac7f9eb3a5868d653e03fed8dd38333cdd29f21ebb166b3b20a9a4e22ef2b22188c286aff7ea7028c7f69b3f62ef929cbc99cbe0c24753a8e5d2c53a310e9299986406a24dfcb732c3a27d62eb5da1db07a61a3badbf3a75f6f77b58259352514ec5e221a8198c967f7bfaff27cb38d86aec64828e7f2d1e00a41d3f8f9449a05b893c29d7631c8ad9b10b58a0ebf849fb7312ad257d1adb46900ebac78b1bb8b834e727efd7443e4d4a14d08fbf4c620d771bca1eb36bb85bd37f2e7dae3d9eb86511e8fb0d7565d95b0f2233c714af3794334eaf497bfd89b46fed3adf549a064f1366ba6cf220597391a053f4b292e551bd18f130c5922f13175cd4ba4247c9c2b9a055726573afca1bdb37dca488a3b1d4c6418f1e71dcfbc98a765daa218f90d8a510322cadc3bf5f506222387683686506cef59fa58c2be7419b2385def094a6e24715c41304aa6a578f03d5f666e4b1ab47180d060f9fc6715a7f62fbe98d3998f29d54db1bd692dddb3c9c2b9db0d26f52dcf67945519e02c0e0118b2dbc1e2d528b6486f7f5b0508a3cb832d578e23069f574ddf5a947895e4c8c1b579458ca0cbb3d0e0a4a8ff724d0eee4064a3312d67de16bd4762068c77a5815ab55ab893b3989d78c215ef46200c06370fa583491395fd640430a047cc9d1e9724b78c9482060de29e46be24eec00314b3190d7cf89c14027ef3da423f9953942bda009a59be8aeeedaf6dabe96c8ee36947e38aae8806f522168a3afe396a3d7fef612ad44b62e052155b9b317344a799c73a6aa7c5d35fdcbcb4e31c58f4d9758efc91ed02d3bce416e73f92d74c057cf00e11fa625a8a6d7cc1d32733eaedd0317d8c41f5f207a8a2534a12783498df6797f77e41593cd2dc0b25126e89d25a604973a8f1faf8a5c275b2338e6525d0baf2e7033e07e3f3fe3821f009feb6194b6e6c084cb1cc897c87f4bbd98ceb48fa5a2afe9b1825bbaa687a36719ba61e63d833ef3b2d71e31aabd0dcd12324cef806c404cf5dc3e6e83e6f890edb4d67bf81129699f8ddffd27937674942614cdbeb5c407d0ace898b02560601fce8b7273ad09f3787e9af4eb87cac040b3f09b43c1cbe3b232950a3f909e515b14a5aca1ec0cfe5caa28bd997baa4fde4c3b0fdb708117a25c987c128c09954bbc22a6965424f7a7023bd434b9ba494ea6991ed0319de4b2c4856d540aca7fd61dc76530865d90a49be288e034b163c2210a3c0053e4ffe462320e49977feebc324b9161a69235d9b6c7eb047b5cdbb49e00423f37f62623d59d0d044aa8c9e5ab52ae427eb30d7804395b77dbb7503fa3a7986add7acdbddf4b0ec026d31d5b98ce443a16c7973ff304890a007a17764bd8839face45a5d57f334819d7a7ae3fec246e67e185b9bef41b4c46010fac1e8de47b2484ff65f2f08dfa7a111641f3ce6caf8392a073a392798dccb1fb8ed1f6a6057e5820d382d3b0230e45d577a6210d3e9190aa344bdfe39f7ff59c6b4f1edd85cbbe11638e8c9cde76ec057631a4c20f855b79a3480fbf8ecbd002e0b3b3fec7206448793b3d2e80f5acc9c6e69fe5643a104402fb8c75c124ec05236ac20c1f0561600d88f437da12438190c08b44c53e416b091d60399aac0a91971e6802374f59bcacbaa1f62f8cb2cb2d282dca7f7cc3cfa448db4c193a8020f3f121791aa9ed44879194f91670abf23f9c4f0493764640d11e99f87420474b2f886d9153fac0f1a6091cd9c1bbb68e91b95a13a517a98ead982aeabd198236c80501dce85ec90d4b13edbfca51fbe859ffc3a4f300437eb73650a8a1dfba45d9fe9823d7519511d0ec592dca5ab9aa184263e23092ac828d81665f2bdee96b030ebeb57d2d30fddaf7ace242d3a79af510c410dc2c0c22781623711cb866dd5b2ca993e5ee56d36c97693929aebc16bd993253fa70fa2866a21566daea25277058599f4febc6f9df004619f00218d4461cb0b9a7e1df8abb2a5e35283b0f2322ee262e3fe114b22f5704524ff68e9e02961c161d6736d9977cab5b5b804f8a029ee1f23e401e8115c2104e22a258f201fee0869b478282eefb8e17ac33e31c39d89db34a147061dd08654273204d52759700ac1bb6def247dccebf37a436c5a2804f5339de41f72ae22a2d4067a7e3287bb9158e97d96f4a6fdf6c7aeb3494f4442def976f5df3fb7587adfe27c64b66bb9bb5cfbb7b594dfc51fe7f47375b2685fa9e0915bc8766386aa22388600fccc28ae57f8ccf7b83e58fce0622b2d3b6fbfc050e8d14c63b37e00a737688b6dde12d824ac99676936245d2920c48b883dad55f236fdce0feaf55da7f89f3c9ead15dd5c5b6f14f9c3c72e465661ccbbf00792b3f347106d211aa69802e426aa62a19173bc9e332be2fe555b00b0ca14342f1bcb3c088c7e6dc760e2bf6f4dfc49c278da0679cfe9e8244118a18c8c50185d6bff296f0aba805e53600121ede71dfb994d3eab543da459cdc20ba685ca38d811cca32a5f5d1afd6f6de4c24c50c6a41b5b36125e95042b85661be85b921bb73ae67efad6a4d5771894ba287661a9793f39f800d91f72510660857e3e4b22c271914f07d73270c8be39170a6110759d150fe54eb3b59fd6a8d15db18d15b5c6f764600265cec69c0668142ea1296a99933f8814756dab19aaa41c7ef906fda9e10bb4bf01f7c1175224c5d73076da5ef17a00ecfb297e8be4253c8c1df0bf6666439868f3827c5b72d710900fb83525a380e3a011c7eb0f7cbbed34674d068534c227904c06dd81febf47cfeb8f3b112ff338663b846026b499eb5bf49280068ea3789295847b690dbf5e3f1bc2f33fa0041eb7bf4e77fed6d7601d82f75e66cd78a98bf39ed284f51f3c4a5b3eb6666d17f93088f4e641343b1163694ab5ee8d7704a6ded657162a6a824a7125d28374ddb4aafa94a866458917b2f02b6c3525691a1a815d26c78fb4e46eae88eefd5bb1f7676cadb3e183fafd2fbb69b5ad36a769bd2f96056cfa5c8bd9525979f87454e0e91ac4d3a524eea893c2ede76d512afdf1bf43a0d2322a406932a8e28845ccf1ec55614371c21f1938308796d5a11b7dea6cdc15b87eeb5391c25531f5ff70a091dc8e6f8a748f95b1e78f0c55ec4848e98667a0d9f440efb753e19a6e420a6ccbdd62cd5f1dab4827e2101c8ba66d625905501cb9c473655a2152e9213059098b029efb40810829b3cdc57184430c4c7876286904297b6b89d222d04a7029ae8d7ebd4e4ef3bd1e8891cbdb4f9b27f5286ff98b4bae2bf272bc5ae885bf9594e135e194a2681021588c4dabd35d7c4a5f754d2a4234a12d0f3d42aa3a305c4d5059757668b90f143bdb543fbc87ab0bb1ed4a00d349f70af5799b0617425ce905113e0ad914c0ad16a6862fc7e825943a38407f7b059ba5ab48e1a8ca8e30aef1161481d48dbed56e75b9cb15e408b2f68dce1925f4c47528f3efb376c4e64894b0b2f1de75f8f5d9f3fb397d526d96d10478853b3d7b0bb0b8c30737be2b99c9915c618df5a78ce0bb55d1f02adfcb9256510c81f1b6d8d46e7c8b35aeb4b04b63069644145a9c8a93dc54b05826fe1332e33be39ed1f7954092ad606491c969d31303452c08f5620f008907667f90b62a1a0d3657e66adf8bc6b9743943deb7206c05bc953ac56a63f6bfb8fbb8899001b69eaf0ce5fd58e7472859ce4a8844059c5c776b023572121674a22941b8c10fd38ed414412c947d903a14ba72394659f3377c8056b2696bbe37f16ea48924b43a9f27283990f71963177b82373be1cd871ea5c7429270a416c8f636f7322d85af023e844261cfb4f61bbd113757c49a8fcd830b3ae3278003201a803c2ce6e526affb46bc95f95ff1c33ea8a1734cf01ef076f9794de3b7d86c023628a60c8c162617a3649bf054d17b60c6b96a2e1fd2e6872c934b5fbc4649be1281d131b2e7926df045665a45accb6854fb9a09a5c83f1d8d05ad883e3ff53a9ab0b558cf46204d1cafcf7ea892e5a3540ae03d3942ddc8c9a4d7be02d0a75a8ce55b0d02fd5a15cb35e5c69162db2e6a13cf8052f994d0cca1dd0e15ebca4c290b90be19f4276865e1e0d0d0391399f0121d36b496dc13423303c1ef071d10b5f395d11563daa56472d51ef710fa19429b9dbd76ca11446eb810396e580eb67042bc7631d714e64bc7fa84eba3ecda7fd62b01b68c38ef2818ac016bd1f2e75faf6c527922e229f79d7fdefc7054a9e72b03802cfc91ae842bd7a00b9b696af9e04fa053871eab20534fd009b459c0ccd5da36dd86eff22d2ee907ba872faad0c0ff94fcd99d484ce97bed707cbc244185ab9ab819c5869b01a25de22d0d433bc12b8f600365dbd87fe235539bdf9f7376f3217573e0a2a6fd9efc2cde1e4f03c70831e1141a90ee47cabe3791eccb1bea95f286b2c42b847489f8bb61e7413e4005e86f1579439d347a036baddbedd0a56384cbbf7bf761951f5a6b6df025ab57c112f42cb83c3cf2706021bc89d90dbba3192e080e8169169bb3420762669a3e9a9b2100341b948630d2be888ca43a09c725cd44a18a41de441cc0719eecd03b4b9af768fa100fb528f45a112a3edd24a929e2fb9da2c2a38b4e051f5377cdcdadb2e2dbac6eb7a70c091fb54941137f8f0be7d0959044e722b1e053d08e122e364e83ec18430b80c80e915495c125a54658ddabe6eac2852b799e251d250a9f962105de51f2ad78227d1f43daa5eceabdf802be4b746043bcd45e005a8c762f8f27a0555cc7c6db3ac623b68b5c7d726ac583be314e858404488b1e8849343f8a5827cbc151c28ebe98022f7b856a3e0e05f516bed5f48cff3b47b5161a8de43036fbdcfe3c22f31c58a2247b16b756a62105e8f7430ceebcf9c8fb0e64862ae9f796dfe0aacfa7d614b68525194d4af7883a94e7c6607c73ad0ecebb5de08edb2558b89d346ba3ff45450621d9e9aade48f769fe91c9d55a8f399efc9e0e3a37ec08dc49398e647154f4b0a8012397466ceeff5704e4015f6d75dc9301246d8bc2ae0c444ec40da752921b861755de04b635f7f6aa34a18b2021d3c7f21f84c3909b029e74119f4083bee6ad4972bfeacef8d0d5e9acde3a21d1aa323df8a59d44c9138c89020803e4b2c2ce64535d9e917f79eafb417a8f2f7978768599266d3527fe6fd0fad57fe783ff3f1f9bedf306a7881d5ccde3d3818065943a954dcc3fbafc4074a5c5fc3bf1010ff7af488aa0e4040e7806a92d2525f73af10834fc2647c01aee53972e6e2981dcea624db006292d334bf9c5801c984c9a1b9255fd19fd13d8a1cb00898e2da03d202869d00d8dede60d5b7d40c83550894f05a1e86e3c67469db76262d19c7aace316c996c89bf40adca2bc679849642424961d101d051dcae850fa9ad6140eddf59f5ce436d6175228c569ef9e2095420a113250c65def77f760b08dc5d5d9f9c5cfacc63f52c755b66c6b4a1ecc6fda8c98b79652db0a77194dc0967c32a92a48723654ae0ac600d5b64fe35ba4038b517bd06674d184ae8e12648856df61d337afb32afba9a3cd2e9692af1ecab3e04eeece65d1019bf5192d3ecd849bd6cc82f4654447982e349e0e6f84af5d08e0ae20746bfe56bda81d645325b06068d6813cf2d355f283c5929a3d6bc23fc3e253699ed1e29d3064f9beb228fe1fd1dff03b5c21c19eb81f1b9e73bd49fec028e2413fb663bc62978dd84f66e8e057722c2ccb5169aa0cf5f2307abc3ae0afbfb00009f38a1c10a5b36604dc25b9196e14bb210ad2be087d961090bc43721712056bc2028992c3487554f883ea1d8bcdd208f30edaab1d6f54707f7fe6bd5f550175ba81c35fd94d78291b24420532cda63dbc633c96b4ed7bf285f50ec64159b1125c17adf3c8df235730f043c6dd5ac6136711a2d95d8031e97fe24db53680ccf845e152376d5e019735ce990554aa69006773113578b4f5a567d6c67f23cfeac125419cc40be4af22a919f1274639880fa599bd1f7e7f8f900e1e646da31951d768fd82951372cd48341a95ef1f173ae6615a242787c1baac9996c35153fab10a3072f29a327480022271bc95f9d36db5cddab22f53cc3dfc00214cc542e2cf86f60a0df0345fb442589f09c91d2b452d6f12e56b0cfbbc45a718416299f18908b3ea6cfd85bfa7f77da364466dca215609ae1b8af7b2ab0657e84097e0ceccf194f956e13d498d6ad3b49b79097418bbe2842056d85cd0a2150d3e7bf0902e92cf452f7bf76e13c2cb80d17ab486a7cecc864e99fe05628cd1a4ec578a912cf346f9f28061218be5d4c3f30d069a85f9ad0ead9d9dae5895899853fe2b00bed9e04207e30807f019f19c65e6079bf38da60a142c370643dcebafd88e7a2d8084024978d6cfeb96d9b5393465a55ff442133eace1b89575c5b76ad1f7bd08b67d8b62b2d9b68e8398c50c4c86bbd6863f314df879b2aab6d16ea543af6fea99f5a84829879aec6fcd8619f19ddbc0768efa96ab7c85725699cde69da62e4d222cbb0fc93289df27ca20a91390fb3989a0687d9d14c24a916ed266eca5801950b3321c30df2af3bb5161694c7fbf57bfb91a419d1057f713b99b90d5f809808458020404dee53e6013138e5c146b390b7f1eb33a54025e33976ad637eec5fce121c8a489777999538e8bd4872e7bb65bda7dc09c119e75df76bd579e1858579f35763721a5a66abb0d0f54fe344c066cd75b9d6f0e123c9b4adc91d5c837d34e118903dc00c7b67c54cd00bc97f314e1127b6cb07562ac57951af1a1154f6260974ae47191a20de9512e27f980efc4985cfaf86972b2a7fc91dc08c5b7c0c0581d61333615d67fb7f12a9fdac90e6a70b831532c4c2d0d483d465e0322a18c7af53ed3f8f258d9400552b4386b4ee2819c19f4cdb3240c982c5b703a9c8c7684109f82a701f6389818f63c41b1c942864637b8a021a6764f894508ed8e91e4b9d9eeb0d26e4c8ae1203636ebe5fdf5c9c1073841a4a0ed25c10446ac7e287f986842d9c4d90cc7663a28b4fe0f26831fa395873f2d57ae223b9fe252868c5b43980884306c8d52d924400d049c83f8c8af199bd3b170d930a04c6bf9b2d6cb1d8a49f4dd40796d6ea2b13b913cc3b079bb2d400e1e2aaf4bdce58e5d31968a7c255f7e0dfc463a6bd52000bce39ba5b8d0ce217ce38ddf35c72e876266eccb7c111fbae4df2e4dc630ac1c087166fea14840a1ce982a8b10ac97e31bb7a12ed8aa96c9f18a79c85e6936e8c6912ffb296ef07f0b7b416d65b72477628700166c20b5ea4a5a6aa87dc87655eac4d511760de2fdbf32ae073d400af5c47f5986630d9eadbf282faa99585cbe6833d110613b680e72f6df0820f0b1c2f5c9402a591284b20371b1d10fb119895972814d50fb3867044c40043709cad8d81f82df95fac3c8cc619ff5a241879cdc3529595ea946f937dad4c226098dc4e9f2d315e704886b1e5b46417ae4ee8d7b97197514e1ec2f1bd425ec4c4df7df8fc213fe7e502eedca86314cbbfe64334793f0dfa958da30a706fd6bad872fb739b8b1a88bc5c7f48bf83603151d1c3162aa4375f0b18147eb48730083b18ee525bad66b1238a089357e640c060dc44c82cc6cd0471abee0ac38e8f2e9a03a2e0c9beaaf4978b6da2d5aeda9ce08d3b0d0e5e8c1fccd4514e4066deb7a43f777080248ac39742347f958c20e283842f4f7daf9f5437390fb385cd634e8b7dd37b8753d2121c8b31d5dcf8898e93be35edf9c3047924d050b5b4911f072009be832a3681a1097627f595c3019bb96ec62f335c6338aaa4fdd15bd088d9686c6e784252546592799057daf7b29d58e37abb9770b5b4ca4874d8da310d826f6b9d7134f16b485e93a81b33c59988fba3282e62c873cef170260361a3d29cc0b09adabb51548c0e4a7f96e3a18b4884fcdc90b8b0c39152024052622d2075c38033276de39a6f91541bf9c0e35fe1f041b1b957d39bcb2542a17d95410ef4847c658d1e84105f7d816f7606a21939ed67fe820f29046a2d21574d8f676b412eeea831d5db2c918d40eafc0e89deabaf303764974890ab5d9575afc2e0dd0c8d67586003136b72edf4e52ad9eed324657320603f173ee4d5a36f3dcd71f60085a7920cf89267665f9970af4c2cb3f9c442889878e29da1f0e8d519c63fae40a3a305844e0c487a2794795323ef2e39705272450a6d56e6247ba0ea4a9ed2db38f3787d11933f3b8dd56a68ea4d50b1c672ce23387930355f7da1783f6e3c35c68f9d75d5a06bf7521adf1aad85af75a839b5dc7ecfb321f2aeae75d6474751e47a0e541d0c590619e036403193db087d9e88774dd0f75062b58608dd0e28eacfe558154b175ab00fdfe27161ce3275fff064a1deb7e0c148d508046567bf152f08bb5c8189c3b292f1058c11b61179d8ec017a529c4bd1f6a9afeb0b77b35582eb0f44787e80dd3c4f61d745513636c2303bc78591d296555108ae6d528a29651d9c5c45af8bc6a08fe773c35ed18bbf1056a4f98a9a9729a13ae0a95d35edcaece50c6d68d1e2b41696dda4d6f17887306b87e611d057d73fdc00d29235722e07d6de94250abf1adaa01889acff01245b76bb2a4a8ff4d283f76b1cad5993257651d61184b1f1d1985452cf4fe285bea8b84e7887b4552acadc629c2a90b43754a501dad4b9edc325a045f350c6911150c48fd2510772d96406ed41822e4e548dcf029ab30d550ca310fe9aadc62d3ee883b021b93dc39624413fa62f459b53a1139cc976e2b513c961ef2cc70f7aafafdb772f079ba636d2ea87f2d4a3fceff387780c6e37aa72fe457e30e5eb23396e71f5478c2bc777d16efcd95b7a6a2933db1fbb8ce276eb7f68cb1d75cfac652cb943f49328ea716dbc5761da7229c2f140e2a179ec263bb9c6e217c6536d8d641171e842c72b38fbe7fee9fe76663c7ac2ca07d4146405fc68260de8895dbd947cb593d7f2a4e88d434769e4a24f5711179c99530a36b7fcc41d20291cc9c678a5401e8746cfdac72debc70bfe09e2f3d962d0d464ecae0600f30f7a9b85ca371852c64ae1e3b9a8f4756fa1f3fdb01b3f1ce5c5317b180e12515a356455eabc3fab3d03d98c9dcb0a3e9eb524416ece8c6a2e1efe0d8d3a90f0dfaf982e2c08128b0887ccfbff41fa80cecb442d7f70a85b6f179e804b12a83f38080b19db8808b03e4dc0e8d20b6fb0fccc03bc09563cf6dbf68ea7b12056396236ca546a4020925db2320732b40721b0f5036c2a3676372bf71b684b3cfaf61112e46a16c9b92df1887bfa665f830662f0f73f92f383f284471f0f8718ee1581ea19a3bea1c8c4908584cc1233ce265f13e0a51b0faa41e2b8780f0bea1afb31d5afec8c68e02a49623f0a08cdc6617a62f0ad5dde3bc98c5c2003e01a0fd5afcfaa511e329aa3c631e0e883b69b59407c572d016414fe042e0aa380373890ddea4c3a705069e8f4096c922af14364ee0553e5f03f57b759ba61e66d3eda469d02512c1d7d5d4d364f921dd4bfe579bf97b6ca2ba8ea51198c6c019de027471b36a82f54179e9efc2b81e3d5861920104baaa10f8cab0c48d50630c2273985d8aceef97b811b42a92cc1cb15890120a01d3a3b6406c3feaaa7dd1bdf80935d620b7f6362e08c00efd3d65c32d99c315c838eb4d4e508fd131516baf19d7c571ef0c3fad6a93aeadcf14823b257538867118241b6e0978d776f5d8567bd57845713f9303ea70918a51efc78f63ad694a81efd19a045495de0410852ec91480b3ff65648f9bc30398e446445266bc53f3beb5c443f38576341823b96c62e2e2e0f58bae79f308b36cd8ec399044d379a6b67543a5b08d5a79c708ad4221727cda53c492b7a0f7210ac57660826e708ca4227fb15db144a3ea2e37d8e433a5ee73b09fb7c47b651e360497c5b6539a10ec32de0119d49e4042edbd8d1f32a6596ad522eaf954c85f51104a88a5976b2bd194e01779a3520160df75f70b70b39ae11869987cee2a09a3f1ad30768affad093e1b5036c6d39eab30c13bb7119c50bc79c746a57c76f28b68483dbcb2f15ec7e949f859f5513292547c7df7d673f916d8d1cd1ad861c2ae654636832a54c1598b0fc7eb8fb0260eef9c5a281db3e3aeb1851a366690b344dec71d22f0398fbbad557cbd9becbacd33d2ccc091650790329311106ec99652f43c3653c6852805e37ad6852126cd34b1ed6e819bfbfbf4f2f01bd04ac733bedb145957232c17e21cbc639144e95d7f6c9b2bb265a10073f4f9e2aff9540ba1dc37c3a4c7ebf16e7dc346af1d1e86456ac7158558420215fcde8ed8e3755c07cd62f8958cf53fda9a06d686ef675061245a4358511e1b81f15d2b8b00e4d3f1c54811bb409ab9ad44489408b3362323d8ddace576cece0293bf31351f0b2a1077471f130bba28ad5ddf45a3c93f325ce24beb92f122642844d2c6349e52706a0538de3b49c67ea0a4f426451f483c3be147bd0881fff0583f81abdf9e8b491428230f01d1692b76a78d7a0b2ffdc989aefb1ea8e1545247fa7cbefbb221cb559e66cf73820e0052a24c9669df2ed5fb61541cfec5863d21d6b73de045d28a841e7a3f021201351dd6b884f05eda956ab5009b031baca405e2d98e6ad6c1244b7aa2df47b2e0587e979668fbd7a4cc503c17f1282386fcf1c3ae1d4d330212401e17de26cd8933205b23b1760a5b957e12e1624e62f364d11e26c4ebee4d2f5a446539f5fc425059e6ef890d0d18e3a90c3ce3c459dac7dddedb0efb8d529298fb31a868c649b82d534f831ad07835be0b2bbe015638be4344c7d890f5d5a3a39bcfbdbe91c5ec16a20f61869b676b0927d3216ba9697d6d2020939ff5b1125996f4dc4c0a054585e0532b787ec017b5921e4e2e548bf4c285433274380efeb52b6746146b2e94af54084b28f7bde4b91ba997006f930256b104c6ad3712389a2c96fd08d193655d0c8196a44f8c9dc37df552f08ca0990fe346a4bef8c3efa69045cdc669adff98acc095f38a2937c250e80415a5c4797dae991970e9dd736706952a5ff20639a4f6e9d65ee7c60b77a47d317339b0f6d112e5a28368760e926b1ca2a20e45f90f0ad57cf97a0ed0bce36c69196ccb2c47494bc909ae3ceeceec9b906f048d9d3781e04f9fc4956ea4798f6a17414c8328f53b3d89a8fc04debccb9788403e375688e7e937e0cc6981f7eaaf8b1f7dd2c9d07aaf16878943101852048f4b890fc768cf7dc70c24e4b278361c66cd28d70f6c302d0011a39c2f1ebdbf565b8ba37b4281b6666bb0e404c1a37d7d59c8bfb03b1ebb67ba6d1f73017c23a842101e1a6ae0ef85aa2acbe995156080adbb7e8fe34e968364b0d92df4965c8ee7b01783bbb3dec92805561b8dc5a687a1b471ffcd5b6e8910d3114d8c8384b15136a801cc348cf5cf8a968f67c21d62a1a5df26124a70dde2465b01d73c3f7ad9ab7e3117d490fc2c8ad89561459248cb369394550fe2020398a9345a472142cfaf50ff004c751a273e39f24877a388f168927de8f66e381507c4ac6a97769db800dfd6ab980fd45dd95c163d7a01c47be95187e30b3607d616e8624b41eb290db6aa3f54a1ba3f65080d28fd46139b09e185adf22dabb1d9edaecbcba340c9b3c4872414239901296a134df0f650859fd7a5a53c0c57d7939dff4aa9d639fda0dafa1f493626868461b14c2647d40d2f09e6d5735bdda2ff04ccca0d90101bae53c0d5167a19ab92b405ff8cf11aa8efea3ce9c44c755b41f9458d6a2a86390a59086c01dbc7a9c46cdaf27fa2e3f8d33f1ea19ead2ee30eb7d27a0d907f0fec27c0e535937f4824456441c4ed55b477b802d3de0bab0832bd04f86457814abd64213b67d6650353320b7b7f5b5578b4cc8f583019a4091369dc37203e006e3f4476cf007ab925259ac85b6747b780c975b38c1c66450be894428e72a7323363f9b6bb536f9702e09df37df30892cf9dd51789e8c271cabcf1b1f9f7613c699d03ef5809163e7d736eb1acb81047e612bfebeed48f2cd581e00b4a012b7093086b0340180a6c542cdab8c2eeb6f6cd6f49f8c1059cfffef58793160187a82e6f916aeac16cf8dbe6db9ec76b04aa7861bbd12436643bcbf8d566b183560253e9fd7e9dda67230d2814442c2ffff1d97e319b72f8091c9a8bbeb677820a935444468028e7131f9e75e67c932652932f90ec7c7a42da5d135055af2d8bfa6c609d5b5f8bec209b932cc284dcb77bdfcd082a760e73c9589f7ec8fb2c5854e8f76333c6840bb0c70a43f55047420eb67dc6220e84d666dbb5743d3733c7c3d3772d7a71cc091acb7bc3b395881ba43a1303716d618ddc30bf3b98a91facdb6666ba2b08c91625ba4697c6d31e1a81ddd7dc692c8417294a4acd5c6b904996c06153feb5d33674828182680ce90d2a12ad23ae3aaae416632640332bba567868c50d7fc4d14b5bcc85bff8de5247acb7bc7d4f9371a2eb6b37462618c15c0c496920ffdc74648c1898e6e30210e3814b8e07b45c9bf3bb2f1327991b1a467aa34d75995b58036c057dd2cd1c2992e34a915b8b386af123ffbbc57df62263261441d3736e02b75807897ad1f650f14d866e7bc0a9dea6ce87d2d78f4f4c5fe303a4e6211370effb605923cf79b12288fc7a923549e72b59d85cae1d7a2ea106c4bb61c2f39f2b7bc71c101c671832c190cae175412abde6157535f596ada931a8ae91b161cad33829fe7370457224c323d186cf9b6f537fdc19472f7796143e52bd2e3fbc076a2d0a579d445712a1bb0451d01443449c49f84a1bcf89964eb38f53efacd16beddeb19dcc7faed6095df8cae4348c3a8910e4ab8cd261d34f0173cf48c3f39046d4975992eb9ed9e95fd392215e4e4c8954cec5ddceded93e4a834eea2ca585ddc2cc67f428368b8fb2ac999918b22784c136f80ba250d94af0fcb16094096716b1313b84d80b5bbe4ee820f354f81c56d9c6f4f5f0ccd1380c0eea397900e864f918b2e88b0ae918edd15c60cc1043ba01327f570e89a918820efe9b8bb23b1c243b6cb7b78475f5f002bda6b9a8d5ae806abc02949d6d0a9334adeb2819b3775afc1e674d6fa5757790946f70801e1868db543d62d88646f59c9ffc4607334d18145b76c01f783a1986443a823cf7d9ca2e416b2c12894a9d5799cad18372a122ab796916c4f27b1c80e083314105a7ca815136be8275784613f4052ce559e967d6134a2c3ba2977fa981f3635f6348c9c8c69e5152d4296fa2d0e56a85681d5e22f280d36242c37968e71bc3ad2bda4eae97b434af86fc5c59e936564d58694ee3845138170b385c57c2968a6f333527b76c9cba37e181ddb79fd6fbffff4e47d6e997c14468d89e2b4505e8ed71eb02cd0da06df1d80f047bdaab6705665315fff103bcf5518ab512fc15ac3299f19c736a680f45ebab5dffe2d6a07e4eaa0500351b553476561c92949879b57bd4b419ee9f108f4b88e47063d1cdc0f76900ef786f4d7a6fcf413e71ff84b48949e03ae353d20ce36a8acb0000d06f4c92a16b35c8a18de9dbee3b34c1d977a45efa468b8fe517adddecf51b54956dd280eb209c1ad72742f43d5b70ca4c037e612c44c718eaa87ffa839b8344dd30da0dcf9f54ac44d99c6baef993f08d5cc8766d07662e9175ba1b3f218a1e59b2ff9f821e8498fe2ee22f575c5f2d34eb6431e7e1c4d35575e08f26933c10e2e4a2c6295e9e32971a7d8958ae4bffc7ddd9185e612e231cb8d2005c18f31451d6fdbbeceffd47605872b3ab88a0267f0c31d4f1aa89d7057ebfd9b0202d398cd95ef753aae97bb01ff75b4a2d97f54e37139ad56b9f165c38b1e4c40bd084c47492fe11809f52b28cdaf342f07c20bcfc400950569333a6116892beaa980ef0cd10b1e305c783e4391f6b1874988573603daf49422a4c0d268076e03dd608425f64dcca63e270df48a4375702706d574c1c2bd699b9e455bfd75366b8f46e5b10a77e070c41efd4cc71fa7a633f514ad12e7f8615320e32b9d01df5742653046e2f103c6008d728d4aa666a704b6854a4c578746f04fa2e79ce8cd6858ae27354ebb6785cda2c775127c9ec8b006f829786a5fa0de887044c6157bea97ae2d648681dada199fb1150192b449cf7fbfc410f5813aba17abcd5d407c4f2b3a9a589ca175afd0fac4fd188e62bc3c24315865e681a7a6e84fccde33b7f0d09f7b9a8fff30517b1a423fbf599a4d849e0828866b9763c0981a2e7645aeb008ca671ef565a4fe64b10c4dbd4be85e68e39cb97dab7a1eb450b60936bf69cbcd865c1aa088f4fd0c9474b303c665994d4ce3cb1efb0e99a5ed7d167ad1668070a9433ab41517729f23fff3b9b2867a0a8703a3c3254f45fa6b64c10d46d91856adb9e479854a0b6a42dc1dd2f2345746ab16b1759be11897f978cf8b76ad6c6c8f2c4cdf02b53f69005d746f84ff3fb8a0646c00891f036967eaab5d801ab87cdc65c49fe3ff66cfbd119d459453351b1bc6d7624c04beb2eefa8d8c5a85e2ef9046b55eea34a7f6410e7ece524947c8f04fad4a6309d97cf7e5002fa0c3d7f6c80f530f612f17acb6b939a60d11d3f17a5ddc77572e93d828b14baac386dae50f46469b994353552522dbde4b709551be8d32ddf6315cf0fc684bacf0795947468a2465972725c533ef25bf97f7ec64d85a09d2dd5a3e21e5c78a31bbb1eb74a4dada7156eba3fdfd494dee7e4a854d078ca8433805e5f4d12e2b55fdf13cb8adff7efab38dde0119f7d4f6fa83bc30ebd83c038409997314b979018dd42454c1fb5235ba220b166e018274edab2b0c7578b4dde06238fb4d0de0e09eb09d14cf43a278d6b734590166286f5f8c3c08be9cf89e24509a128a95c1f18c9bcd08e9cfe8530d6d5b77d1c7abf53728f21d0bded33b958e7603ba3a5ec66492b142758ef00beae92c2ced2716df73d15ece74f6f220b1f5a02a3dc843be34eaded117dcf44449a44ae62a2d1c1536663587024ffa17fdb303e12b629a85cc4a19a36f816717c05d6c8957857dd6e3b072485a0173ae78bc4692f11b9920a27509463cc543dbaf3fc58ec9be7fb59287084c2093f755dba04051e76e91a6b8ff42da03bfcd2b2a4ddd353beeeb50e3cfb920390fbcf1270d7989bb7989bebeb203df4806860a3a09723e8f31641c6cf5894d1ce3fb316e4116d13bce942b371efa78274881f72463149a8e6e249de897a8c5b9897be92df78e63828247e1b6b0093f80b7bc31dc05c0a1761d20fcaa452bd4897a187a9a3ab8a384e2023ba19d306d700f5aac846e5f4148f388e58e2d666a5af7dd4e3c0a218868e71eceb5509d69df98beb79cdeba7608690807c01b3c0b1ad8d20a83e6855642a0081e95ce8d49135a92f6ef58cd963fa818ecaa613cb4100280ff2173b53a59701829a8c982e98ef1cb06eea67d06eaf3032c787a4c317be143d2296f011a5214660ad12729a1d32c8ac3b2f61709d8b945d016e6b0e17e0040fe0e8b98b2adb11299098c57e8f6ef78ddbf149c49e78d941f4b084ad33e09baf7e48eb7df7116450b34d8048c59facc1508d234c32de5315735b969642cafe68bbba8369fc1966061bcc4b501748d64ba9f8e8c9f84353b2870c02d2e733861694f7ad3076b26dc6a3cfa884baca4098922fa4b2808deba36de22bddd3e414e375f245e1489094997733dc0b8763babcc851c8a3bf7425d8e6a08ee37c7587b8d4d7fb2a3e3cf25eaf66eb4d9bc7106a21dd73d5fec68972e259daed8e6b87b1b216c8e6e98b7501f0edf21bdcb94913f54eb0643302b6a6f2c083e8f239f425cf3b7e58a5dff53b9448332099567a9949d1bef3b29c17ebbbcf1af7849ad54145dfaadeb77fc6581c3b7d76bfb3b9ad8f3b009d5b390027410d474de6a09215eca186c1de4e52895eca5a5bca8b1d5c14161e0d8fd3def6625968a539384a7a9bac9cd2a4a86805b5472599b6b4a7531ca64800a31593414de3138d0e4116d67da7efbf105fe775b72489c9b07899c8f3d6891196d4fd295995f1b308f3c4873c35ae680c59744ca1a128bb332ee7fe51445bcf76b2aa0f7bc3b2bdf9eb683446899b149bf496889568850e305c3d861b26e77f008f7126d94aece16399615aeb8d1d8f8dee51cdda1e8278f8a5cf94c8674954b33be6d7dfa26b20bdbb59677a91c5bb9bc4ef8dbbb5f799182a97db30ae8ce0a7849cd0d4397fc9e4849eee7851a79efaaa1918c9c47959b9a18691d78e8a36f69816a7a310223e2a81e4de6f8c769c04021f2aa4f6d70d4473ed49ebaca17ae8102861d8c98ee4bec7cafcdb14dc5bbe46c3dbf27f8303f58b419f83d3487190a0d94e6cfc42a41ce1454ff3899615a21a2b00ee705cea0e7986f5fc3535968047f2959d4dddb80aa410c164550aa35648a6bd06dad91ec661e8598a7c24ef999dc8f98749355955dc7fef64189202b3857f916c9ab53737e61de5ddb65d7ef13443a576cc233fea2dcfb9801bf95e3a741f3acbf9e78e2bc48f7d3d28b809e4223ccc73e4f61327285697405ad012420fa6ff3bd30a162e6510cfcfc98f63204207891809b52b8d0d41068323c882b5e1910abd6bfaa3fa0e4a3ca2691e8e5a0afbeafbfbe8af3e77d405c0a3fd267365e2fef56475cf2d808f931246874b6a320c54b4adfa568a9e8c05a5cb5be329018180ba5eb6fa6b4eb59fcb8dc6b409287448689d8d9c84d5ee842692954e6ecb95258783ac043b3b1f171671a5d3bc38faf0a2035342c36097853ac77db7aacfb71a544fb4e0061b5900b480edd6c79dce240803dfdebd0f89c57e1daa96bc7de13c1c79e041ca5f8206e496e039bc16e9c5f34a6d470165a35b90a0b25b27e5476e606ec111e517e1bde1e6a1a8163dbd9d93dc500c7aca456d11800ec3c460f418e657edb5e9c7656b9d06feb0c5e752963b7832646f9ef2193c3e2e76f9822ed6740d0d1effe14b5c5891701e1071577b6108737d3a0cf574ec2546468db60d486890b46043ce1ef1b866242f29c0a137b0647af6bd0f62e7db75c20b121a15cd8ca5e72d3eae52b33dde60d1ba20f62d51e1ff3eba095f58a4bbe2212770fc412d851aeacfbea70a21b0e85fd3459bd4f247821af25a054760197c94d018de6a90068f4485ec3e226d69ab3d802c2f89a1f508d1bed650cc4589c1361d0032abc038668287ab54b48ab8c7f8f38b31b3cb102da1767c3bbf77bc29ce9ffcd305d12a0384d89cae110abeeefd37b1cc29d86a5856276a00e0582b47941d2ba940b3b84bef1dd1eef0c20b6e2876eb4c21d2b26040c9c2162be8c370ed538daf59c94d042c13a83d5dfa8d22a72a83d977f7a69190f0a58c29172955c99f4fb3981b4c963026dbc88e89415380da1bc080c65af767c51222de839c27f839997dcbff6db355aa2bf42b66a8008cac6f9d103b30ae422659a646c3965adf0e0bf25ce907a6127b428cb4e44851be4d91755add0a3c231b12919dad1e3f686311cd40e5a849e3cbc26eb6ee23553559f7af9cd8f6acbb745459af34d1b6e0007ca52855d772d97980265ff744a55cf878a6d92a6030696c7ff44ef8a58186fd086a35dd7d9cf94d798264f83ff8acefa32a0fa46a3312f36af61371d54b4385adc4b123e776290e7508ae01ffe3fa6e61bb00a75cb5ac5f68d1b7ad76be8a3ed95239b27c3b48f10bd21b4cfeb9f65b46a08fd13af145c7ea4ea2accd23bfdcfc6f99f60d8482b259db899e4469269311d5ea6e1e21aecaf873626e01d236204f90e7d2959dacb100b30392f883c1febc9dc6447b752c49c831a92b895ce106680f00e2eb80a58c2659195add350a2893d6cad4b9c180e68c29718007b0fc49bc52dd88c66e558a8a18fe6459accf637a03dee758025445f91efc34f5c565a3b9881ef7cba3af3529dd4b46cfb3d06d4913e84bdbb7c88561a531e5a5a973daed9becf7edc99891e9b7f5152e62ff53b7b8b1233136bd5b2b4081c3cf22541d4e45876aea83e464dddb55217f079c98635972db2d97a416525653f604d059823f1ce8f730db86f453a8eb256b51fac88c54070e2ad082bd7b01b4b1d920aa276b9766bd6debd60da2f32ba1f664be8d74be7775c862a5e64cdc303c7a161912e8973174a71f7a6a431151bbde91ccc9824868576ef2df9c3ba2c76074f1c133cdb05c98ad3b08365834396cc37828b9508fc9ffe4425148f2de4d9789774fb90280d2c56989ebed7b3eb8fc614bf913b95c18ee507e9fb36b641f9088e11cf2f911da33ccbb20b39cd7a2f6eee0f2a993d232df6c54e92c06535141a03b23b4fbfaf75eacb71ef81367ad66076ba0a976d81265cb740ff77a85e08dfd1bf87f025658423b9a82335b73d894dc2f9ce460a869b9d5ad721a456eb0a61d59bcb34cf168e8ff86d87cc271df7136a375ec10505115396e6b52867572dbdd8d6e814d422a8807ed7d5f05ee8e30093987265e3366e335dc0215577b176f898639bafccf86e72b9a990f7c337801657050a5a46cf409b9daa1a5e0c88c71916b1400066dd8f20abafbb3c252b7987e321554669c1f41127be37969722fe5e13d9ee73ed1e1a186a8cd7aca79b6f22b470ada12f3a33280f591d7ef37b811b0ad83d0ad17f6bdd73a86b9b6be03a0c08f7905e1760870a7d5969dee3102ad09c20d3bfa0fe1b8bc8ce66d0ee75a90d1a55aabcb1f35788c563b31b148245d661ea69282f4e62c3f5fd6f1935df9d74f74da610f5b5c64012bcc7c5ffc42242570464963500bd8b3986fab49e8f060cd8b65a75851c6adac089627962c4a651adb58ee12b90582228de3c88ad8ca693fb61c2d6086b852b382fc351f84c44f2eeb47a802abdd23dc0b31e0bdbfe6e9da6a86772373c31bf0cf2bc57384d3e23c6e69007a6d110a2883f6ecf574e23e03686359213dc09330a8140e7e4ad329c2e171142aa6f164ff497c58b6a6a9f2be65ddcdcdc2a96bcd1e6acfc5158e33c638ee251900094832b1ad0cfbe2ec6573712386e3c97dfca1226916051127331638579bc14efee6e45e9e380285f6d4e9bde3543f67bded83cb6ed3c7e81af7e9753a30c587a8b247831a6fa4d54ffe3a3fac32219bff92bae9ad8839eb961611b0cdb76ea81ab6db45ed7a87afef67c0b9e2f3814d9e733b6f0bf54ea4726e6f5cb22b1caba4fbea0de1df8d85f97e24c10f9dc2964ce3dec544a4caa22f4a94c60ecb232335447bb815d5520beb866af0edc97ed277373c6496010508cca66f6c6de15eae6295b3acfa09b847ef22bb8c0a246055393ec3c58791d747c0481f27b3732bbfe88837ed09e3d80ceb48d3a068df7fde751554710d5f9b6e9ab83cd5f99ac38266dd2f5b3e919b565a9de230e38ab6d3db2446412073c0ede23c2b17bfe6e2d2c7320e3ea1c6d66dd6a1d3837a93732c875c4f251dff8a490435fee6af48052542601db258df37348f19a1ed85bf2bcd8da7e13bdb7fa553255acb8276cda5b08222ccf52a566b67937394025785b84206e563d4a3f3ebff967f1b48a44f0552e00bfcf366dc3cb564d15bea3107b7dc9cebb270807a8fb0a1411ce350464f84619bae3df1fe4b223fe73e33c58903a3c59c8d1d6168b1c365984f24e478917b2968294c83cc95846cc7ecf1b137ce8af7859d234a0450bee8bc1d303c5a6482b09332b5c2d2e324100d4d192f58b7c704a09b4263b83190bfcad5606a3c538f3f0bcb3b047c7a850eb707d48580c7366b8441d048bc2a7522228559cf5b815ae13cd74072eb89008d50b76319d2d576eb7f7beaa3c51c4505651ed746ca7aa003cb04e3fa63f1f3ec151258e8bafa837e47fbce2361b34b3f89196e5be894968c71e935448dea4086f1cd05d424c4efadf03415dbd9270a07783be2cf44dfd0729de96c3ed5f1f556f91bcbed7c3232aa17a74d16dca8e2ccfb7e057d81d9740044408be6bc39b1536aa47caad19c2245fa0bc562c708a85dae384ee683c630d326ccb36c60af336b7338541bdac32d3f89a8fe444d8f04d30a80e37389709b787e9c1042964f23a3cb50d7e9c7e0f8ec9c7ee5f95744baf94af7c21664f670a8788804c9691e0fc110b2ba7a539520dad784b0f599ea723eadc2d8d7854c956a6acb8b89e3a03e3cd579beecd315c9b62db4d020154077da4bf24c9b66870e884db84d8a329ede186a0753831a8ed1bf475621364494ed716cc51ba29e10ec0b350d47ba94b0e237ffffd8b870927cbf073a238447aca1cdbb4b3ce8a12eef70fcd1394b2ed053cda7d166154c283c8f7dac82704eb81ee1a66a6f47262b1e254310d56a3f6241cfdb2995f8b01f0ddceb0249b56c68459b4bd0e806bd9601f6607c4e256602c53de1d7acb732a82d1b0decd4fbd45737540e0d2dea555e3e4b247f203eecb2e3fde87d6fe98917100bf27a91b7529f50b4c9d247b49189146807ac8d61d60da98dc32f3e5614cd32f0ca785625ff673a2366eb7a30af8be73ff25bbd4640db1f3eee1cc7e3c31bf3b7a8997b63fb4ed3fb3bbd2933b61c69d63f0b34a4d26e05902db7b9f9c19508a685c782a353718ccdcfccd2ee6a5fde343b705ef18d3f611e6d67297a73c68758d9d4257d61ca0605fa075f2aa81593f4095099b635513769d09ec5a86f89e817568c596b8238d537dcfb15d31faae0e00d5014fa9f1cfb777fbc83bea56dd343cf09abe6e066b5ffe8e9be87c9eda1fe6a83cb5f1d20e274b27e826ddcd82283866ce249f7a57f5e5ee9af55764045e499d5ac0689dcc78fa786ecc1902d5b1f76852f159442dea8941ec84618d010fe28d3fa7099ffe326a9f6705ac03c039b7fea907fdb180c868f9b5e2b6d4858866ef8a6c03d7cb6ee59e4027514cc7084e7b8816a8299bccde8e1b22100291b6298d85e18562f197beae6f6200b1a6d1d1e1be239d401f2f37a0b7e8de026ba8198f7737096849d8cbc4fc00235a664f8f763db89666e562df9af9d5fbd7793ec2e7a1d32e820fa274f0c0e0f47394778638446b8ccacf67a8cb6e442650fb4df1c92add857c647cb4ded4932cfe520a5d3e86f9a5c0e54fea99b5ef63f30546b04c3a7c016b5503b0371562e3147021dc6a6775a8e5cb916bd4a5947c0be73946b6e6c6ffa1a8bce7cfb5597546df4ab65d31aca4799b6987d49ec26daf65af25fd110780587671ce2ae995703d8517f6c1e7d9a02df02a42dfa0d55f0de72053d98a21eb31cc06dde5ec53e979becc550f4c573be38ecfcbb2fec30693a24a2bc67df9989a148e581fbfa1cefe3553ed7de5f1807c4858004ef86124f785156a8332b690aa84401b4f7fd65ff692557d2e62695086c904b0f9b92c7e409f1b2b30ba1cc45c12a516fb7cdeccffa4eaef90babfd1415eb003dcbda11496853cd28df581207b6f607c4c5c8d91d6b3f5d96de51f0edac07776e45ddd4f5d2a4a233ed8147538dd06b958bc8041fd7cbe18c28eb2c679771f65ff4dacfcf628eef61bb7cb7cd5b13e0cc2fd85f6fc44f20768b3d6fbc7006c8eeff1c526370c204adee9ad9b268050b39793bddbba85f0d2d6941f52324ea43ee7a7778505d3f70a753cd78a38dd38a65e2a34763fe7ed78a739f45841a345f409344d94636a18121f368302382e8b2a410524f9cc6d6ebb2099ccc6d8cceb614b12439e080edd2ede7c3c536a5dac7f5397c24ce896e37090d9452f1cf72c50892244ab1d7d120366f52113855710de2b066969e14d9b9c3b3e187c678f98277721ac2ec3b49045bfd474e7eab15e4588ca87f653c67ccbff29e0d297f9a493e2e9fa486eeb174c8249ac3993942627fe09819b1e7163533f3bf5f60159a572b9d790f6b6199d9f735710281c819e9c33af50417063506d31d374ce3bef54594ebcfcaef3cd5c7c6907324a4f23cbe906e8c08fb9a5eb141cd5388d04ec00feb0da0e74edcb1d4a62f28f4d6361381b5905d825967d814b8439e93162bc7524ca015835b65b6bcbe30817bfb21175a2ea0c71eb4009034e0934936ad32b7cc2ceb08679bc8c20cb4f64383954ed133b2bd9cd6d8a827f387be77b2f88b536d9ccf67bc5514ea9aa46c814a2b0b69a0ba66ac040be555fd2c0d9712b7462be6d89e94a0c59c279d43694bbbcc973d524413ec21b1f43ee0d51cf0b12924a09d808c53542ad668e44878802277509a5c6b1dea5261a61b60c38989838c22ffc3b190065e2aa62c232c5dec9df54db013e7ab58f34f04e07ebbed06411d235ce4d3cd379375406ebf8af18b62a793e77d0dc33d62aa9f468088b955afa31ad170896eb486f057ff75405a25810d716cd578fbfb5614f027604c18947600b75ba65f324e6a405d2e4e2ac901a658332015064d0253aef3e9efb06f0f219cc674bb91faa96922706145698f9b7854a479bd746c95369613901d4f8cb1726ae2e579515cb662c5806688d70e522d7b2437b8e81112de6d8d5ccdd70f7773e7e4836bff18ec98da9a4f1e1a29db98a854dcc1f93c39c081a97b5208392c1019ad299d04ba02c4a358c8b652625f5c55166c3ebfa5094c3d1dab024ade51dea5c3d4ba1cf2884f949e5d932a93c5796fb54a31c1512f5b661e948ad1e389a1182a6e71d8d32daa1b00954e790763f33c5cd15f9a12a16a6c70499441f3684c35c15ba2ed0f83bb21a03152d36ab8a3d3e07b12fd908ffec0cbbb0585b79d848446224b22b752bd273f6fc10061b199e0736a8071aa1c78fe8e1b02c0199aae689517442f54aa6fbf2e9e7eeddaf96e799458ab9c8c669256b517fdbd3685ca9011ec262af19e049c101ff8a12fa4a1bdb17673027eeedd8e794c5c6d30eae38abe8d5025d0d10d14371459bb9d4ccc83d8d6c2c88ff7a6f61e888404c7338fb493cf017ae2d63300360c00539124c9c5aefbfdf051125126556435a1c8e3b740aa605136eff9d3b37af79d5825846609a5fba0b0d4133c87b786768648aef9289b9d7eb2445492ec696b210175417adbf83b196992d90c2359dc75f593b642c0d823aba35008e2050a47e99bed706c3c146af368255fa74d425639614b79c4db916aa5909890ea01c057688ad475f621a84f6796adc7c8ae3b7878ae2afa61614cf55c5b3407bcb9afa0daf2ef1c65eab32dda7daa6d6b606998091dedc7925fdfd04718ba073ee21114957ca04eba998a021b8f18e2200d4e8e10ee38d0df3adf3f8b752a7a691247f5e6c2b3a78e13fe39306b4d16bc5c2c9ba75c6b8df4fe030332adfadf086269e353684b0b08984e1b79b03b6ff795e722d949a54bd218db025184ee8f0016dfb6b86ff524ef3e4a081d0f4f25f6089eeb9311604fad40e7e0e22d10ca59ac626ee2e1eed5d9af149c60be3b833e705bbd302629ee78e83a510fb35563a3c63bd80c01cdf7747569e2873b38b549ccaddb41d7d4b072d95b81631bcfec08ffc2bbf7d3cd42774a8a80bf92757bf6b388280d50e181538e4deb2ddc64d070b27e24386b289ccbf47f552c56852d6c2af61fd33481c7ee49a2f6371fbf1e922bda7d31961589b485fc80e9aa381b3f863c20bfa3ee3344846f9a0e74c7e2abd78dd00a5f914a99b028a190d666079c99ea0be0ec06981bcea41d6105e8fbefbf5cc44624dc5f0c736d6a4d32797dab9cc6711427fe5f861f4829d55cfddf3f724be60d50453529741db3abc8dca30e7a85ce894f555625861f1b2677e3236ee517771ce6d5626aca46eef6dd55b588558a60158e05be63b7a8fd52b8036c1535942cd96e0ef3948de5e02095bc84745c2adcb6dd4e7a9c2a680e97c74d90051ac8d9c9ed59baf6e1c4b1649e8e74c1e7af0794aa37ec5c1b1ce6d1d80c448e4750a22d4445d8db57e929eab51fbf27adc4ccd150a931b8d288c39dc15f7079d36b6616d361fb6eb89729ac972118260c32bb0affd51aa52c6e75239686168440754c04c81f25636d6544802e1490b0a5676e3f5c869187e387fa086395a4095463da23bbc023cb0505d03f041eda1b8674405bfa39c035efdd9811baa4c7ca1c0c302b1159732448dbce26da197e1d6d51efb8f34c237f6b352b36faab0cc1a40b333c3e8d6d2495dd64bc0b99b4c6e593331e43354ae2fc11a9383efca07b9bcd0bd28d2b9ef37fe2e30a4c1eaef90b07f2ec639c8714442c575cbf40db05c808f8735d6af3fd1a7493affaac05ebca4a8985d179abfdb31f18968a68ce505049df8f47f6c8f315d728344e73444d2e99484b73e31f979a46ec67037320a5e1f1ea13b7624e38505c091a461f82a99c6edecf1561555b534e5250836d669c031bbde4bb4697043fcd1078228d8e75518531f55e52a9cd34112f6341952b299bac1f7dfef11920ce4174bdc48e5c26161db2e19ebdb7beaf49eaa7368c6ca92869a8ef7a564f75ef0eb56a18d3ba24c0b83194903459334844294f4e568888d5e045a58dec4197ee380a2e2926cacebcb4b52f12f0da5683c90c861d701004536d7482a9c099ae05a33f803e4b52220ee21a226f62cacdec4d2be1c54226aed47a9b6a9ce7ce8cba375d5a33b03f71b59adeb68b8052ad47195ab620ea298ec73d4a32439dfeef47b35cb79461646e52843e3a48e726bb6728ceeab396bc831d2a0fe453cfbc7c3ccf586819bc7e97abb7c281da04d22663b634bffaf579b969177dc6bd1f69cd698f54bb82e1b5e0e79a811ae44a6000c52c1952ea0220e167a9b4f14e8e715a7bda2d493e123ea304bced492afe551a07bdb440c24e760448a20bdf739c08cb8fef71267e1e2da819099343e750f60d399bdfee7dfc063b6942863e0171e0d0fcf5f252b81a46fbca88a0dd66f49e95421a5ed724d8707cf224b3a381a1b9ea7c57f7bc5cadad85a3830fc613aa1fbc163a9fecb2d891809d7d083c86a01e19410990679a2a74eebb0c549677f0078c5814cd0ec86996ea82a3123e687676ae7c55994329fca1c89ad7c0d6a1bd257fecd43a0631236e650b6e1e780ba36da8dae9d3f576dc710135ce2a5e3128ed0cbb086d2ee12fb7fc665abbbfe43b02722c1ee69f0e07880a4b11c161b4fe8cb730aeeff9f54a1424a72c9c6e465c6fb849cb2f818caf9b446bbcddb869a9d3a6a8dedfe9ac0789b36e71e0c975e20ff3c2f564e7011ac3a6869b06f7b03a8616cab36c04e4c627728aab55c8ad93cf8aa220dd2ad1ab411814105cdd64ef7e1531a4c5e11e040647be2b447129f628088f3fb1737a7dd5c1dc4c348a51970ad57e954ef93c1bff99ccf3128d9f332ba8edb603cb03290147117200f6bada968cccca400a5d42f613e63a0a5da86c02cec43ba4867bae13672438ce2ea8e075fe16a8fc85282aa46515ea659633b1f9d4bf4e2b6257fa3b0e15948572a3926d31b468c44df59cb750ca9a9dfa7501ccf42addabca0537131eb99bb4eca849bcaa71acd5c97a9e954c79dcd14bfc8dc014b936eb89ccad022fd63b58b2faa8042ed438b011b4e1053c5159bd9081ca341ede98f1f4212e764fdccf4d286b41e8fa23faf9aa807e08225b207e1d40bc374fe41d76ea3a8be864f2c270966fd3c64098d51bc1adb1a80bb9feedceaf23d3e981cef57d3e2055292abc5f2fc0c6e392ffdda9f4fd1de1730dda193aee1b3d1b910d228497e3ba1b25b8ab577280c9b897175517e472e5e46c480a5363eb31332640128ccc9fb15364fc4e58a7017d3306b332c54f0125cba4efca02b07ae7f106c63a23e736771922e4f3c6869bd5baa2932fa36a88289cac85359a5eba3914691856a523ca9cfc81d8cb58a838ce853984a95b1450690ed5fcbee626e1b43c2324c17b47b2a30151565dc1f031abd73eb2656285e7d398be6c8a7751fbc5690690fb44c5f26e779a3bc80ec808048ef5e1763d5ae3bbd7632907d0840c3f09d27dba99bcfcdca0de623c348ae3638d805384f2d71ecd229c3654aa573492c01fa3161850572d753f784438d87bab499338e026c03a753dbdc77051389c16b1f12638b3fca361ca73b2a8fce44aa78d3452d40200895958397e5216c68f961b2b079c2482307466e58a5d0ffa5fd544e479021ac141bae854e86cd3cbc9f9f13857368b0c98c07a664b4c05ea660d8b750645580f771216e76f3783126d3fd4915c64bd5160722d60ecf413516b32056928f22e4e3eb93187ab5824a440e2baeffcd05be906a81963906417be81154c1fb8ca2563523fe9b7054dfc784909d29ff9ad0a61910b6ec643998db70e7802da2ea855d6388cd4cd238a6adcda032f5779fb08c1569060767a149ee99e7bffd855c5dbd04da43cccf0f709e292bd11a8a64bb5638c49f36322dd75d5ae93daf509434ff391df07d099916dffbece15a81478cb0d59121301895548bc4e45af13c19043c11f81f8826ab77db9a6b416fd711b480522ce27b04aed3b4889b2a4b78c0cd61eaf598f3c77a3d7d95158b4a43021843fec5760a28c2aa957ebd8b405508a292680bb7fac231c0f62ba76ca0ade3c637728e9d170b7084d70e6a27245d5ced64212f24b0598455775105c92e0e36b46bf822cf3de213efb7243d5e753f05aa250258374bc848153b36d2c3cbd968fb57be26b8fa0e07c2da57811ae81b8686a2103c863e6a98dac28fb7896b300b6c2c4b5cd4b0b97c7a9115afedff7e1c7bb7b689f364c1ff42b71ad5a674f6cb758b7b8f932cb94227cd61813f6c1adf95e97f60ee5d7801b54460a1268bf43e83a5e9955e691e672de024d9194540d19fd716c2bf7c92b8985c582db55d4894f6a96c643a944bbea70f4fb94aa6afb5fad310ce4a1be28ed7e12d30f9c82426607cbb62558185cee017c995124c995e5eee579e491e60f547a4ac4dd1d2848e03c7049ad861e30388199a8599484210abcb5d11ddbe35a58b35c1c8581120b0533f4373434c042cc5c5ae6d30be0d724048c0a04cca5f3d8edcfd879b826fe8a0d66a4d7170fdb505346727948d1d3c2774930ad3b09bd32d6bb6b78e5fd59eb07530ea3310e5b18c22a9a7f9486cea5f11d5f1dc8694382164f391c44fd73abf243888641f441781e121d2641dd9bc1b025edbbbe497a2463b181eb2d4274111d4ba1582f768e481496323072ab9899e59ec9bf1cba5c48b88bcb0030be507a7d02c2cdc47793982a5ce482d9e60ce9df805667accf8d9602a4fa219e5922f8e8729d218fdc1b51b0c64621045ac5f7d803812ea9ef08f30afd5cc517a346f87c2a82c172af622df609cacb32cf777525f514df3180b5d184554cc005099145e912033d51f522d3b8ea6c9b89f1cdad28fd2bdeeae2653b3ab63ad7540676985530a98b47791d8b9805f111bc36654a8eace435d3a11b0c9e828278036e7e53c170934d050a2b69eecf56839ccc10b8196bdea9b0cc0ed03e22bfddf1420179f9c682fa1b2668ee05d217cd94bc95c360bd287a4324373a223d5f3b990ff4dac8427ba1e2f9fd10ebe9da5069fc89f4c38c8456dfa635b2270922ac1b9e29a62cc57e9d64f3f82d85447250f06dfa41bdee1d166c42d9d2cd87769d8d4b3ce5f3929b97257d1b520f92cbc02c5d69cb7aa9fe72a90750e907b9a775a1a70de148463273c3376da206fc7e60021a08c9d7296c24b4e2c3e14ca090cea5c56cb38c220b97e51b8897a83823b1a656eae525baff1fd201e9b0dd514035c513764ed7a44c5f3ab1ce129f270486e73d92822501fea17535c733b3926af5f31c0f7e3ebcbc64f11b31d6f3eda7bbe2a272815ced158d307d185d60348872ddfa1e4565bd09d4840920401c6e7a95ce3e4fc672984d10d28a0afc873eb8db0bbe13c08a7c6664ddf233b60243c6244d474e32a697b5231b0f426f964d31a07a4e7489c868e8256df4d8e54e037f06aff8814d45fb926cb0b1ed7278b60fdfddd9b7a0623f2e7f0fe9d8430c886c9c2e292d294a96a22d2846469761b46dad142e6ff57fec63017b068e21a5ef83ab2b777ad83698934b9e637ea1402ad2ef8708948c000cd9abd85e1ad35f9c78faaf9ce1fe92eda52a22b691ed847011e62d0c448f147af75c3bb6262eaa473a709f94f2fb854eb47afa457ae472514be868296abe1478cab9c9999d9c1fa34083bf07459617a9b00789de0c14871a39eb418defa7c9071304eb3e3562e0975c37f4df12dce617a9a1b0948076beb7562cdf8a210896e4846e2460c396af00ac6554c7980edfb614ea7cb6f5cf73862fd7891b05ee4741d48d945f54f9b21317a72070815dc71d3b3d973b71c7b22a7e06a6a7288df3e7bb533784846ebf8e4a98385d94e2d0119b255e62727fbd32d95762d2608409fe0ebf08b5c457753af2c8d1f26ce4e045ed6f360f29196d71133b74302c700c133fe1795fe187e5dd09ea6e15b67abac3f977baba0817aad5177a9ec0c9d9142cfa0cdc0a7caba115ff27765b361fbe1934f9939647a486085076a2e2384958814c0dbde9b44f38e7ad5d3b0bcf7903aeeaceedfc9cf0d6fac73977541d08ddd1be7d6a8b24a4281632818e323816670f2c93f27ae23c9c2a4a63253d7eb7db148d722c0cca78e499d50a3ddb0ab3dc8f6b1ed82a72a96af10742007429a287f82648e3be6154c605fec9e2aefefaf6f7ee2a86c028fed32ca6214be8c85d30d87dcc5555a21be8fa888b90a7a157cee39d79b3f5c0281e6f150c7e7b4c266bff39f5ec4e7a2f5c7bf2a1ef1452ab774c317fa1fde8b598b90b1af1ea459b84616ae0c01db65f3dbbe681eabf64f874912f51618ce1d3d7ccb557cfc4f5f2b8a9895f173abfb0064453327dad0dbbef3aa7b2b23795f30649a048201e872e1b1bd78ff0002c1779356d79efa22133ea8b5f124faff12500c263f6608fc0a5989f3eb28d42f372c64fc7e39c8a94fad8933cc20d516e27c79077421e97f1dd29f09e6724edae4d23f4f91d16aa64a4993ec7964b9aeee13f3f857c00accf38d523e12b46cecd480b9b9e61e1918f46e83998331987280a9d41a80f555d3ce82fb788329cdcc55f2ea851155a88565f7f2165974e443f088ad7fbf23af420813981b8b5d6a46d9376e390584024c780301df2f3a3ad7c7767817cf054c8eec612ce1962f1d9b2690d3504f0b9f65644312d2524da79739f6ed1d2babc4a654c14f33d21f42ab89a97ae23f82dc81ff80dd99b1c04e18f0071e33c4c3661b6aafb0c3e89187955d5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请将你得到的密码的字母进行26位凯撒密码移位后输入到这里。（？</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>QLUOJ题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 370 题解</title>
    <url>/2024-09-08-atcoder-abc-370.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,3202nd,Solved ABC,+22</p>
<p>因为博主太困所以打算等下周空闲时间把这场和上场的题意补上。[TODO]</p>
<span id="more"></span>

<h1 id="A-Raise-Both-Hands"><a href="#A-Raise-Both-Hands" class="headerlink" title="A.Raise Both Hands"></a>A.Raise Both Hands</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>打表（这能叫做一个表吗？）即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">if</span> (l &amp;&amp; !r)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!l &amp;&amp; r)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Binary-Alchemy"><a href="#B-Binary-Alchemy" class="headerlink" title="B.Binary Alchemy"></a>B.Binary Alchemy</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>按规则模拟即可，为了缩减代码量我直接采用了 <code>max</code> 和 <code>min</code> 来替代一层 <code>if</code> 判断，增加的复杂度无伤大雅。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">    <span class="type">int</span> element = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ele = <span class="number">1</span>; ele &lt;= n; ele++)</span><br><span class="line">        element = vec[<span class="built_in">max</span>(element, ele)][<span class="built_in">min</span>(ele, element)];</span><br><span class="line">    cout &lt;&lt; element &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Word-Ladder"><a href="#C-Word-Ladder" class="headerlink" title="C.Word Ladder"></a>C.Word Ladder</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>显然，因为修改本身没有限制，所以最少的修改次数必然是两个字符串不同字符的字符个数。</p>
<p>下面考虑如何让每次修改字典序最小。</p>
<p>显而易见，将一个字典序大的字符修改为一个字典序小的字符，字符串的整体字典序会下降，反之上升。而字典序的比较规则是从前往后比较，即为前面的字典序下降对整体字符串字典序的影响更大，而后面字符字典序上升对整体字符串字典序影响更小。</p>
<p>所以，为了让每次修改后的字典序是最优，我们首先正序修改会导致字典序下降的字符，让字典序“速降”，再倒序修改会导致字典序上升的字符，让字典序“缓升”。这样的解法就是最优的。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; inc,dec;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; t[i])</span><br><span class="line">            inc.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt; t[i])</span><br><span class="line">            dec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : dec)</span><br><span class="line">        s[v] = t[v], ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(inc));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : inc)</span><br><span class="line">        s[v] = t[v], ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : ans)</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分。</strong></p>
<h1 id="D-Cross-Explosion"><a href="#D-Cross-Explosion" class="headerlink" title="D.Cross Explosion"></a>D.Cross Explosion</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="朴素的暴力"><a href="#朴素的暴力" class="headerlink" title="朴素的暴力"></a>朴素的暴力</h3><p>直接根据题意暴力即可，开启O3优化后，对于本题会TLE两个点，但是大部分样例都能过，证明只要在暴力上进行优化即可。</p>
<h3 id="暴力的优化"><a href="#暴力的优化" class="headerlink" title="暴力的优化"></a>暴力的优化</h3><p>暴力的优化一共有两个方向，一种是用数组维护当前节点的相邻节点，另外一种是 <code>set</code> 记录目前剩余节点并二分查找相邻节点。</p>
<p>我赛时写的第一种优化，没优化出来。</p>
<p>但这种优化好像有些边界条件模糊，还真不如二分set好懂，于是干脆只写二分set了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// set + 二分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, q;</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; w &gt;&gt; q;</span><br><span class="line">    vector&lt;set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">col</span>(w + <span class="number">1</span>), <span class="built_in">row</span>(h + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">            row[i].<span class="built_in">insert</span>(j), col[j].<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        row[i].<span class="built_in">insert</span>(<span class="number">0</span>), row[i].<span class="built_in">insert</span>(w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)</span><br><span class="line">        col[i].<span class="built_in">insert</span>(<span class="number">0</span>), col[i].<span class="built_in">insert</span>(h + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = h * w;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">auto</span> it = row[x].<span class="built_in">lower_bound</span>(y), it2 = <span class="built_in">prev</span>(it); <span class="comment">// 搜行</span></span><br><span class="line">        <span class="keyword">if</span> (*it == y) <span class="comment">// 只炸自己</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans--, row[x].<span class="built_in">erase</span>(y), col[y].<span class="built_in">erase</span>(x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*it &lt;= w) <span class="comment">// 搜索到的it不到边界</span></span><br><span class="line">            ans--, row[x].<span class="built_in">erase</span>(*it), col[*it].<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (*it2) <span class="comment">// it的前一个不到边界</span></span><br><span class="line">            ans--, row[x].<span class="built_in">erase</span>(*it2), col[*it2].<span class="built_in">erase</span>(x);</span><br><span class="line">        it = col[y].<span class="built_in">lower_bound</span>(x), it2 = <span class="built_in">prev</span>(it); <span class="comment">// 搜列</span></span><br><span class="line">        <span class="keyword">if</span> (*it &lt;= h)</span><br><span class="line">            ans--, row[*it].<span class="built_in">erase</span>(y), col[y].<span class="built_in">erase</span>(*it);</span><br><span class="line">        <span class="keyword">if</span> (*it2)</span><br><span class="line">            ans--, row[*it2].<span class="built_in">erase</span>(y), col[y].<span class="built_in">erase</span>(*it2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Avoid-K-Partition"><a href="#E-Avoid-K-Partition" class="headerlink" title="E.Avoid K Partition"></a>E.Avoid K Partition</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><h3 id="时间复杂度-O-N-2"><a href="#时间复杂度-O-N-2" class="headerlink" title="时间复杂度 $O(N^2)$"></a>时间复杂度 $O(N^2)$</h3><p>二维 <code>dp</code>，定义 $dp[i]$ 为在选定点 $i$ 的时候，从 $1$ 选到 $i$ 的方案的总和。</p>
<p>初始值： $dp[1] &#x3D; 1$ ，终值取  $dp[n+1]$ ，过程中的推导式为 $dp[n] &#x3D; \sum_{1 \leq m \lt n} \left(0\text{ if }\sum_{k&#x3D;m}^{n-1} A_i &#x3D; K \text{ else } dp[m] \right) $。</p>
<p>注意：虽然这个式子中的$\sum A_i$部分可以用前缀和，但是时间复杂度最坏是$N^2$，这个推导式过不了本题目，要对其进行优化。</p>
<h3 id="优化正解"><a href="#优化正解" class="headerlink" title="优化正解"></a>优化正解</h3><p>可以发现转移只会从 $\sum^i_j {A_i \neq k}$ 的区间来，所以分别记录目前的总方案数和上述区间的方案数，则 $dp[i] &#x3D; sum-invalid$。</p>
<p>开一个 <code>map</code> 进行缓存，令 $mp[pref]$ 等价前缀和为 $pref$ 时的合法方案数，则 $invalid &#x3D; mp[sum-k]$。答案得以求出。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    i64 k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    map&lt;i64, <span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>, all = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += vec[i];</span><br><span class="line">        <span class="type">int</span> invalid = mp[sum - k];</span><br><span class="line">        dp[i] = (all - invalid + MOD) % MOD;</span><br><span class="line">        all = (all + dp[i]) % MOD;</span><br><span class="line">        mp[sum] = (mp[sum] + dp[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2024ACM集训队第一次入队赛 验题人题解</title>
    <url>/2024-08-31-2024-newbie-1-coord-tutorial.html</url>
    <content><![CDATA[<p><a href="https://icpc.qlu.edu.cn/training/6648cfa00ee9c1c358afe5f3">点我补题</a></p>
<span id="more"></span>

<h1 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h1><p>我的代码有一个最基本的多测架构，具体架构可以参照<a href="https://qwedc001.github.io/2024-08-25-common-templates.html">板子博客记录</a>的 Template.cpp 章节。对于多测场景，在 <code>main</code>函数里负责读入数据组数，并且在 <code>solve</code>函数里负责每一个单测的解题，这是一种比较好的习惯。在下面的题解代码中，我只会给出每一个单测的 solve 函数。不再赘述。</p>
<h1 id="A-网络竞赛平台与小鹿与正在检验你是否是真人请稍后"><a href="#A-网络竞赛平台与小鹿与正在检验你是否是真人请稍后" class="headerlink" title="A.网络竞赛平台与小鹿与正在检验你是否是真人请稍后"></a>A.网络竞赛平台与小鹿与正在检验你是否是真人请稍后</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以开一个桶记录从 0 到 9 每一位在输入数字中出现了多少次。题目要求没有前导 0，则首位肯定要从 1~9 中最小的一个数字出。然后就是从 0 到 9 依次输出即可。</p>
<p>针对于我的验题代码：我采用了字符串读入并遍历字符串来快速检索每一位的值（而不是每次%10 记录完后&#x2F;10），并且采用了 map 代替堆来进行遍历。</p>
<h2 id="代码（验题程序）"><a href="#代码（验题程序）" class="headerlink" title="代码（验题程序）"></a>代码（验题程序）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[ch - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(mn + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    mp[mn]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">        <span class="keyword">while</span> (v)</span><br><span class="line">            v--, ans.<span class="built_in">push_back</span>(k + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码（新手友好版本）"><a href="#代码（新手友好版本）" class="headerlink" title="代码（新手友好版本）"></a>代码（新手友好版本）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[num % <span class="number">10</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, num % <span class="number">10</span>);</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mn;</span><br><span class="line">    cnt[mn]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt[i] &gt; <span class="number">0</span>)</span><br><span class="line">            cnt[i]--, cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-ICPC-与小鹿的差旅费用规划"><a href="#B-ICPC-与小鹿的差旅费用规划" class="headerlink" title="B.ICPC 与小鹿的差旅费用规划"></a>B.ICPC 与小鹿的差旅费用规划</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>签到。输入 $a,b$ ，输出 $2a+b$。</p>
<p><strong>但是</strong>，很多人做题的时候，一个是不明白多测的具体含义（这个我给出的样例也有锅，我谢罪），上来直接开写。</p>
<p>另外一些人则是做题不看数据范围，或者是不知道给出数据范围是<strong>干什么用的</strong>，这就不好。</p>
<p>在 C++中，int 变量在记录的时候，其上限能记录到 32 位二进制均为 1 的数字，也就是十进制的大约$2\cdot10^9$。而题目中给出的数据范围在 $2\cdot10^{15}$，明显超出此范围。</p>
<p>所以，要用 <code>long long</code>。</p>
<p>十年算竞一场空，不开 <code>long long</code>见祖宗。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a * <span class="number">2</span> + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-CCPC-与饭后消食的小鹿"><a href="#C-CCPC-与饭后消食的小鹿" class="headerlink" title="C.CCPC 与饭后消食的小鹿"></a>C.CCPC 与饭后消食的小鹿</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>本题为 <a href="https://atcoder.jp/contests/abc240/tasks/abc240_c">Atcoder Beginner Contest 240 C 题原题</a>，并且数据点也是直接采用的 Atcoder 公开的数据点。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>小鹿每次跳跃都会从上一次发展而来，所以我们可以维护两个数组，一个用来记录“上一次跳跃”所到达的点，一个根据“上一次跳跃”到达的点计算本次跳跃到达的新点，然后每次计算完成后，用本次跳跃到达的点的数据覆盖上一次跳跃到达的点。数据范围足够小，不会超时。</p>
<p>思考题：这道题正解是动态规划，怎么样优化才能将暴力代码优化成动态规划的样子？动态规划是什么？</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> last[<span class="number">10200</span>];</span><br><span class="line">    <span class="type">int</span> cur[<span class="number">10200</span>];</span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    last[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cur[i + a] = <span class="number">1</span>;</span><br><span class="line">                cur[i + b] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            last[i] = cur[i];</span><br><span class="line">            cur[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last[x])</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-百度之星与小鹿的铁牌"><a href="#D-百度之星与小鹿的铁牌" class="headerlink" title="D.百度之星与小鹿的铁牌"></a>D.百度之星与小鹿的铁牌</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这个需要在纸上自行模拟一下路线，也就是为什么ACM竞赛会提供草稿纸。有些数学题不动笔墨是想不到做题思路的。</p>
<p>模拟路线个数以后可以很轻易的发现，从 $1$ 到 $n$ 的路径个数符合斐波那契数列规律，问题转化为求前30项斐波那契数列。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fib[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 需要先在 main 函数里执行一次 init</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>, fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; fib[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-蓝桥杯与鹿与小面包"><a href="#E-蓝桥杯与鹿与小面包" class="headerlink" title="E.蓝桥杯与鹿与小面包"></a>E.蓝桥杯与鹿与小面包</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>智慧题。题目要求删除若干组数以后恰好留下一个最大的数，我们逆过来考虑，有哪些数被删除以后可以留下。</p>
<p>当一个数左侧有 $n\cdot k$个数的时候，其右侧也一定有 $m \cdot k$ 个数 $(n,m &gt; 0)$，因为题目保证经过删除数字操作以后恰好只剩下一个数。</p>
<p>所以只需要计算满足条件的数字的最大值即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> num, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span> ((i - <span class="number">1</span>) % k == <span class="number">0</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, num);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="F-睿抗与小鹿的贪心消消乐"><a href="#F-睿抗与小鹿的贪心消消乐" class="headerlink" title="F.睿抗与小鹿的贪心消消乐"></a>F.睿抗与小鹿的贪心消消乐</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>模拟。按部就班的写，注意判断特殊情况（比如三个格子相邻且都是万能颜色 <code>.</code>）即可。</p>
<p>考验代码底力的题目。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">grid</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; grid[i], grid[i] = <span class="string">&#x27;$&#x27;</span> + grid[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;Point&gt; <span class="title">vec</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; xs, ys;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; vec[i].x &gt;&gt; vec[i].y;</span><br><span class="line">                xs.<span class="built_in">push_back</span>(vec[i].x), ys.<span class="built_in">push_back</span>(vec[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">            set&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">            <span class="keyword">if</span> (xs[<span class="number">0</span>] == xs[<span class="number">1</span>] &amp;&amp; xs[<span class="number">1</span>] == xs[<span class="number">2</span>] &amp;&amp; ys[<span class="number">1</span>] - ys[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; ys[<span class="number">2</span>] - ys[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pt : vec)</span><br><span class="line">                    <span class="keyword">if</span> (grid[pt.x][pt.y] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(grid[pt.x][pt.y]);</span><br><span class="line">                cout &lt;&lt; (st.<span class="built_in">size</span>() &lt;= <span class="number">1</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ys[<span class="number">0</span>] == ys[<span class="number">1</span>] &amp;&amp; ys[<span class="number">1</span>] == ys[<span class="number">2</span>] &amp;&amp; xs[<span class="number">1</span>] - xs[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; xs[<span class="number">2</span>] - xs[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pt : vec)</span><br><span class="line">                    <span class="keyword">if</span> (grid[pt.x][pt.y] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(grid[pt.x][pt.y]);</span><br><span class="line">                cout &lt;&lt; (st.<span class="built_in">size</span>() &lt;= <span class="number">1</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Point pt;</span><br><span class="line">            <span class="type">char</span> val;</span><br><span class="line">            cin &gt;&gt; pt.x &gt;&gt; pt.y &gt;&gt; val;</span><br><span class="line">            grid[pt.x][pt.y] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="G-天梯赛与小鹿与字符串维护"><a href="#G-天梯赛与小鹿与字符串维护" class="headerlink" title="G.天梯赛与小鹿与字符串维护"></a>G.天梯赛与小鹿与字符串维护</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>另一道模拟题。也是按部就班的模拟就好了，需要一定字符串知识。</p>
<p>如果看不懂题解代码，请先学习完C++的string字符串部分再来补题。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            str += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">                ans += val[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="built_in">assert</span>(r &lt;= str.<span class="built_in">size</span>());</span><br><span class="line">            str = str.<span class="built_in">substr</span>(<span class="number">0</span>, l - <span class="number">1</span>) + str.<span class="built_in">substr</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="Fun-Facts"><a href="#Fun-Facts" class="headerlink" title="Fun Facts"></a>Fun Facts</h1><p>1.本套题目的主人公是教练鹿老师的儿子，他现在也是一名信息竞赛选手。当然，我们事先在出题的时候没有告诉鹿老师，所以他在看到题面的时候乐了好一阵。</p>
<p>2.所有的比赛背景介绍由我撰写。包括梗图也是我找的，看着感觉是不是还不错。</p>
<p>3.一开始想要拿一道大模拟做最难的题，并且一开始想要放在 A 题的位置。但是我们担心大家都不会写，最后取消了，放了个比较简单的题在 A 的位置上。</p>
<p>4.A 题想要教会大家两件事：题目难度与顺序无关，题目背景与题目无关。</p>
<p>5.消消乐题目经过了一次数据削弱，但是削弱后的随机数据卡掉了我的验题程序。（削弱后随机数据随机出了 <code>...</code> 数据，这组数据成功卡掉了半数验题人的答案）</p>
<p>6.榜单的颜色不仅是想要对应彩虹色，比如青绿色和青蓝色对应言和和洛天依的弹幕应援色。所有的颜色都有对应的 VOCALOID 应援色，当然是我自己搞的。看看有没有有心人能收集全。（？</p>
<p>7.想要看大家比赛结果的我过于热切，于是物理补考只写了 30 分钟就匆匆交卷跑路了（？？）</p>
<p>8.感谢所有集训队成员为新生赛做出的努力！</p>
]]></content>
      <categories>
        <category>QLUOJ题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>齐鲁工业大学ACM队内排位赛 2024秋季第一场 部分题解</title>
    <url>/2024-08-24-qluacm-rank-autumn-1.html</url>
    <content><![CDATA[<p><a href="https://icpc.qlu.edu.cn/training/664b4d4450be682a1fe01296">点我补题</a></p>
<p>竞赛结果：Solved ADGH。</p>
<span id="more"></span>


<h1 id="A-01"><a href="#A-01" class="headerlink" title="A.01"></a>A.01</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果 $0$ 或者 $1$ 有一个是偶数个，则一定可以通过操作将它们全部反转成另一个数字。所以只需要判断两个数字是否都是奇数个即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">count</span>(<span class="built_in">all</span>(str), <span class="string">&#x27;0&#x27;</span>) &amp; <span class="number">1</span> &amp;&amp; <span class="built_in">count</span>(<span class="built_in">all</span>(str), <span class="string">&#x27;1&#x27;</span>) &amp; <span class="number">1</span> ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-肥胖基因"><a href="#B-肥胖基因" class="headerlink" title="B.肥胖基因"></a>B.肥胖基因</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这不就是一个模拟查找。不知道为什么赛时写锅了只有80分。可恶。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(s1.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">substr</span>(i, m) == s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; i + m; j++)</span><br><span class="line">                a[j]++;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="number">0</span> &amp;&amp; i &gt; temp) || temp == <span class="number">0</span>)</span><br><span class="line">                ans2++, temp = i + m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>)</span><br><span class="line">            ans1++;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-春游"><a href="#D-春游" class="headerlink" title="D.春游"></a>D.春游</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>暴力就能过。推数学公式还容易推出毛病来。注意 <code>int</code>范围不够。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    i64 ans = LLONG_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> big = <span class="number">0</span>;; big++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> rmd = <span class="built_in">max</span>(<span class="number">0ll</span>, n - big * <span class="number">49</span>);</span><br><span class="line">        <span class="type">int</span> small = (rmd / <span class="number">33</span>) + (rmd % <span class="number">33</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> money = big * <span class="number">3300</span> + small * <span class="number">1900</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, money);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">49</span> * big &gt; n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-找7"><a href="#G-找7" class="headerlink" title="G.找7"></a>G.找7</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>说起来你可能不信贫僧是用DFS过的。实际上 $k$ 的范围完全可以缩小到7，因为最坏的结果就是 <code>1+1+1+1+1+1+1</code>。所以再往上的 $k$ 都是吓唬人玩的。将所有数用 <code>map</code> 预处理一遍 mod 7 的结果就好了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> end, <span class="type">int</span> curpos, <span class="type">int</span> curval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curpos == end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (curval % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; idx;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                idx[d[i]]++;</span><br><span class="line">                <span class="keyword">if</span> (idx[d[i]] &gt; mp[d[i]].<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                curSum += mp[d[i]][idx[d[i]] - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[curpos] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(end, curpos + <span class="number">1</span>, curval + i);</span><br><span class="line">        d[curpos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">        <span class="keyword">if</span> (vec[i] != <span class="number">0</span>)</span><br><span class="line">            mp[vec[i] % <span class="number">7</span>].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (mp[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        ans = mp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(k, <span class="number">7</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans == INT_MAX ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="H-路径"><a href="#H-路径" class="headerlink" title="H.路径"></a>H.路径</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>搜索入门题。是个签到。迷宫类题目真的是搜索必会了，判边界之类的。</p>
<p>然后我个人习惯用 <code>pair&lt;int,int&gt;</code>充当 <code>Point</code>，非常爽。可以用 <code>priority_queue</code>。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Point start, end;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">vec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(m));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (vec[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                start = &#123;i, j&#125;;</span><br><span class="line">            <span class="keyword">if</span> (vec[i][j] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                end = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, Point&gt;, vector&lt;pair&lt;<span class="type">int</span>, Point&gt;&gt;, greater&lt;&gt;&gt; que;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line">    vis[start.x][start.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [step, cur] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur == end)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, step);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : directions)</span><br><span class="line">        &#123;</span><br><span class="line">            Point nxt = &#123;dir.x + cur.x, dir.y + cur.y&#125;;</span><br><span class="line">            <span class="keyword">if</span> (nxt.x &gt;= <span class="number">0</span> &amp;&amp; nxt.x &lt; n &amp;&amp; nxt.y &gt;= <span class="number">0</span> &amp;&amp; nxt.y &lt; m &amp;&amp; !vis[nxt.x][nxt.y] &amp;&amp; vec[nxt.x][nxt.y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;vec[nxt.x][nxt.y] == <span class="string">&#x27;@&#x27;</span> ? step + <span class="number">3</span> : step + <span class="number">1</span>, nxt&#125;), vis[nxt.x][nxt.y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The End!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>待补：C，F，I</strong></p>
]]></content>
      <categories>
        <category>QLUOJ题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 369 题解</title>
    <url>/2024-09-06-atcoder-abc-369.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,4815th,Solved ABD,-14</p>
<ol>
<li>博主忘了写补题博客了</li>
<li>本场进行时正在线下进行新生赛后台，打的不好。C题居然没想出来。</li>
<li>因为是补作，时间比较紧迫不再提供题目大意，下场恢复，这场择期补上[TODO]</li>
<li>FG还需要进一步梳理[TODO]</li>
</ol>
<span id="more"></span>

<h1 id="A-369"><a href="#A-369" class="headerlink" title="A.369"></a>A.369</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力求解即可。为了保险把范围开的大了一点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10000</span>; i &gt;= <span class="number">-10000</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        vector vec = &#123;a, b, i&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="number">2</span>] - vec[<span class="number">1</span>] == vec[<span class="number">1</span>] - vec[<span class="number">0</span>])</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Piano-3"><a href="#B-Piano-3" class="headerlink" title="B.Piano 3"></a>B.Piano 3</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>将左手初始放在第一个左手音符上，右手初始放在第一个右手音符上，所得解法就是最佳解法。因为你需要按顺序处理每只手的音符。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            L.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; L.<span class="built_in">size</span>(); i++)</span><br><span class="line">        fat += <span class="built_in">abs</span>(L[i - <span class="number">1</span>] - L[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; R.<span class="built_in">size</span>(); i++)</span><br><span class="line">        fat += <span class="built_in">abs</span>(R[i - <span class="number">1</span>] - R[i]);</span><br><span class="line">    cout &lt;&lt; fat &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Count-Arithmetic-Subarrays"><a href="#C-Count-Arithmetic-Subarrays" class="headerlink" title="C.Count Arithmetic Subarrays"></a>C.Count Arithmetic Subarrays</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>从左到右遍历，找到不符合等差数列关系的分割点后记录，计算 $\sum{\frac{x*(x+1)}{2}}$。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](i64 n)</span><br><span class="line">    &#123; <span class="keyword">return</span> n * (n + <span class="number">1</span>) / <span class="number">2</span>; &#125;;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i : vec)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    i64 ans = n;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] - vec[i - <span class="number">1</span>] != vec[i + <span class="number">1</span>] - vec[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">f</span>(i - pre);</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">f</span>(n - <span class="number">1</span> - pre);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Bonus-EXP"><a href="#D-Bonus-EXP" class="headerlink" title="D.Bonus EXP"></a>D.Bonus EXP</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>状态转移的dp，可以证明不会跳过相邻的两只怪物，否则解法必然不是最优。</p>
<p>设 $dp[2][n]$，$dp[0]$ 表示杀敌为奇数，$dp[1]$ 表示杀敌数为偶数，然后在两者之间进行转移即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    vector&lt;vector&lt;i64&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;i64&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = vec[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][i - <span class="number">1</span>] + vec[i]);</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][i - <span class="number">1</span>] + (<span class="number">2</span> * vec[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[<span class="number">0</span>][n], dp[<span class="number">1</span>][n]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分</strong></p>
<h1 id="E-Sightseeing-Tour"><a href="#E-Sightseeing-Tour" class="headerlink" title="E.Sightseeing Tour"></a>E.Sightseeing Tour</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>数据足够小，这题用什么寻路算法都可以，跑一遍两点之间最短路以后，用DFS将所有可能出现的点与点的连接方式跑一遍（枚举所有出现方式用全排列，数据范围够小可以跑的开），求 $ min $ 即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, <span class="number">0</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; bridges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        bridges.<span class="built_in">push_back</span>(&#123;u, v, w&#125;);</span><br><span class="line">        edges[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        edges[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res_dis</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, i);</span><br><span class="line">        res_dis[i] = dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : vec)</span><br><span class="line">            cin &gt;&gt; v;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> dfs, <span class="type">int</span> cur, <span class="type">int</span> i, <span class="type">int</span> sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == k)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, sum + res_dis[cur][n]);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [u, v, w] = bridges[vec[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, v, i + <span class="number">1</span>, sum + res_dis[cur][u] + w);</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, u, i + <span class="number">1</span>, sum + res_dis[cur][v] + w);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(<span class="built_in">all</span>(vec)));</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>齐鲁工业大学ACM队内排位赛 2024秋季第二场 题解</title>
    <url>/2024-08-25-qluacm-rank-autumn-2.html</url>
    <content><![CDATA[<p><a href="https://icpc.qlu.edu.cn/training/664b4d4450be682a1fe01296">点我补题</a></p>
<p>竞赛结果：Solved ABCEFG。</p>
<span id="more"></span>


<h1 id="A-好朋友"><a href="#A-好朋友" class="headerlink" title="A.好朋友"></a>A.好朋友</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从 $x$ 处出发，分别向左右两侧找最近的房子并且计算距离即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; m;</span><br><span class="line">    x--;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    <span class="type">int</span> lft = INT_MAX, rt = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; lft == INT_MAX; i--)</span><br><span class="line">        <span class="keyword">if</span> (vec[i] != <span class="number">0</span> &amp;&amp; vec[i] &lt;= m)</span><br><span class="line">            lft = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; n &amp;&amp; rt == INT_MAX; i++) </span><br><span class="line">        <span class="keyword">if</span> (vec[i] != <span class="number">0</span> &amp;&amp; vec[i] &lt;= m)</span><br><span class="line">            rt = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(<span class="built_in">abs</span>(lft - x), <span class="built_in">abs</span>(rt - x)) * <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="B-三元组"><a href="#B-三元组" class="headerlink" title="B.三元组"></a>B.三元组</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>记录每个数字出现的下标，然后对于数组中每一个数字 $a[i]$ ，二分查找其左侧的 $a[i]+1$ 和右侧的 $a[i]+1$。并且用 <code>distance</code> STL 来计算还存在几个下标符合要求，相乘即可。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i], pos[vec[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> search = pos[vec[i] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> lft = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(search), i);</span><br><span class="line">        <span class="keyword">if</span> (lft != search.<span class="built_in">end</span>())</span><br><span class="line">            ans += <span class="built_in">distance</span>(search.<span class="built_in">begin</span>(), lft) * <span class="built_in">distance</span>(lft, search.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="C-平分苹果"><a href="#C-平分苹果" class="headerlink" title="C.平分苹果"></a>C.平分苹果</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>赛时写了个特别难绷的模拟。</p>
<p>赛后队友点了一下发现，<strong>不进位的二进制加法 &#x3D;&#x3D; 异或。</strong></p>
<p>于是就成水题了。</p>
<p>只要异或起来不等于0，无解。否则和减去最小值即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, sum = <span class="number">0</span>, mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i], sum += vec[i], mn = <span class="built_in">min</span>(mn, vec[i]), x ^= vec[i];</span><br><span class="line">    cout &lt;&lt; (x ? <span class="number">-1</span> : sum - mn) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="D-套餐"><a href="#D-套餐" class="headerlink" title="D.套餐"></a>D.套餐</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>背包 dp，还是个二维的。</p>
<p><code>I don&#39;t know how to write dp I am dp 低手</code>。</p>
<p>（大雾）</p>
<p>对于第 $a[i]$ 个食物组， 有 $dp[j][k] &#x3D; min(dp[j][k], dp[max(0, j - a[i].first)][max(0, k - a[i].second)] + 1)$，跑一遍取从 $dp[x][y]$ 到 $dp[N][N]$ 的最小值就行了。</p>
<p>二维背包要跑三次 $for$ ，记好了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, ft, sd, sum1, sum2;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a[<span class="number">305</span>];</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">305</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">305</span>, INT_MAX - <span class="number">1e4</span>));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; ft &gt;&gt; sd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">        sum1 += a[i].first, sum2 += a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum1 &lt; ft || sum2 &lt; sd)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">300</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">300</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">                    dp[j][k] = <span class="built_in">min</span>(dp[j][k], dp[<span class="built_in">max</span>(<span class="number">0</span>, j - a[i].first)][<span class="built_in">max</span>(<span class="number">0</span>, k - a[i].second)] + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX - <span class="number">1e4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ft; i &lt;= <span class="number">300</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = sd; j &lt;= <span class="number">300</span>; j++)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i][j]);</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="E-取球"><a href="#E-取球" class="headerlink" title="E.取球"></a>E.取球</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>用队列模拟并且每次在出队一对球以后将新队首再次记录即可，麻烦一点的小模拟。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bar</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> ball;</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">            cin &gt;&gt; ball, bar[i].<span class="built_in">push</span>(ball);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; ontop_idx;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; both;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ball = bar[i].<span class="built_in">front</span>();</span><br><span class="line">        ontop_idx[ball].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (ontop_idx[ball].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">            both.<span class="built_in">push</span>(ball);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!both.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ball = both.<span class="built_in">front</span>();</span><br><span class="line">        both.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> idx = ontop_idx[ball][i];</span><br><span class="line">            bar[idx].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!bar[idx].<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cur_top = bar[idx].<span class="built_in">front</span>();</span><br><span class="line">                ontop_idx[cur_top].<span class="built_in">push_back</span>(idx);</span><br><span class="line">                <span class="keyword">if</span> (ontop_idx[cur_top].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">                    both.<span class="built_in">push</span>(cur_top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : bar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!it.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="F-航班"><a href="#F-航班" class="headerlink" title="F.航班"></a>F.航班</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>带点权的 <code>dijkstra</code>。可以在板子里找到对应的模板。注意 $N$ 的大小。</p>
<p>哦本题需要缓存一下结果防止爆TLE。没有其他问题了。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, <span class="number">0</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    value[s] = vec[s];</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[from] + weight &amp;&amp; value[to] &lt; value[from] + vec[to])</span><br><span class="line">            &#123;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">grid</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; grid[i];</span><br><span class="line">        grid[i] = <span class="string">&#x27;#&#x27;</span> + grid[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                edges[i].<span class="built_in">push_back</span>(&#123;j, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res_dis</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res_val</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, i);</span><br><span class="line">        res_dis[i] = dis;</span><br><span class="line">        res_val[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from, to;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">        <span class="keyword">if</span> (res_dis[from][to] == INT_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; res_dis[from][to] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res_val[from][to] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="G-商品"><a href="#G-商品" class="headerlink" title="G.商品"></a>G.商品</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>可以 <code>dp</code> ，但是有没有不 <code>dp</code> 也能过的思路。</p>
<p>有的，优先队列处理一下就行了。</p>
<p>记录每个物品的保质期，按照保质期倒序排序，在第 $day[i+1]$ 到 $day[i]$ 天的时间段内只有保质期到 $day[i+1]$ 的商品可供售卖，将他们扔到一个池子里按照价值排序即可。排序这块用 <code>priority_queue</code> 就完全OK。</p>
<p>本题输入逻辑比较逆天，所以 $n$ 放在了主函数而非 <code>solve</code> 里。注意一下。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; days;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p, d;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; d;</span><br><span class="line">        mp[d].<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">        days.<span class="built_in">push_back</span>(k);</span><br><span class="line">    days.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pool;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; days.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = days[i - <span class="number">1</span>] - days[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : mp[days[i - <span class="number">1</span>]])</span><br><span class="line">            pool.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &amp;&amp; !pool.<span class="built_in">empty</span>())</span><br><span class="line">            ans += pool.<span class="built_in">top</span>(), pool.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>[Trick] 随机化的 Hashing</title>
    <url>/2024-09-22-trick-random-hashing.html</url>
    <content><![CDATA[<p>参考文献： <a href="https://oi.wiki/misc/rand-technique/#%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%94%A8%E4%BA%8E%E5%93%88%E5%B8%8C">OI-Wiki - 随机化技巧</a></p>
<h1 id="基础思想"><a href="#基础思想" class="headerlink" title="基础思想"></a>基础思想</h1><p>异或哈希用到了异或的性质：相同数字异或为 0。</p>
<p>引入随机数的目的是做哈希运算的时候减小哈希碰撞，在使用 mt19937_64 的前提下，随机数强度足以避免哈希碰撞。并且，异或的上述性质可以保证当两侧的哈希相同的时候，运算结果恒定为 0。</p>
<p>异或哈希主要在面对 set 判断等价的时候使用。</p>
<p>还有前缀和哈希，主要是在面对 multiset（也可以说是 vector ） 判断相等的时候使用。</p>
<span id="more"></span>

<h1 id="以-CF2014H-为例"><a href="#以-CF2014H-为例" class="headerlink" title="以 CF2014H 为例"></a>以 CF2014H 为例</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>经过读题可以发现，警长作为后手压根没有必胜策略，只要罗宾每次打最大的气球，最后的得分一定会大于等于警长的得分。</p>
<p>那么考虑平局的情况，不难发现警长只有和罗宾先后手打同一得分的气球才能打成平手，也就是对于每种在区间 $[l,r]$ 的得分为 $x$ 的气球，必须存在偶数个。</p>
<p>这个问题乍一看很简单，异或前缀和以后求 $[l,r]$ 区间异或是否为 $0$ 就行了，但是实际操作的时候，不难发现由于给出数字比较小，很容易出现碰撞产生错误结果的情况，于是需要对每一个数字进行随机化映射。例如随机化数组为 $ [1930204585,12390125,485989234,1239049102349012]$，则源输入数据的 $[0,1,2,3]$ 分别对应了随机数组中的三个数，他们的 $xor$ 结果就不会为 $0$ 了。</p>
<p><img src="/images/pasted-0.png"></p>
<p>这就是随机化哈希的思想。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rvec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : rvec)</span><br><span class="line">        v = <span class="built_in">rng</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;u64&gt; <span class="title">pref</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i], pref[i] = pref[i - <span class="number">1</span>] ^ rvec[vec[i]];</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; (pref[l - <span class="number">1</span>] ^ pref[r] ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="另一个例子：ABC367F"><a href="#另一个例子：ABC367F" class="headerlink" title="另一个例子：ABC367F"></a>另一个例子：ABC367F</h1><p>本题来自 <a href="https://icpc.qlu.edu.cn/user/53">@Sun_M</a> ，非常感谢！</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个题目的要求是分别选取数组 $a,b$ 的一段区间，问能否让这两个区间重排后等价。</p>
<p>重排后等价，则两者的数组和应该长度相等并且和相等，考虑用前缀和（注意，此处的数组可能存在多个重复元素，用 xor hash 不可行）。</p>
<p>用随机数将数字打乱避免碰撞即可。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>; </span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;i64&gt; <span class="title">rnd</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : rnd)</span><br><span class="line">        v = <span class="built_in">rng</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q, l1, r1, l2, r2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">pa</span><span class="params">(n + <span class="number">10</span>)</span>, <span class="title">pb</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : a)</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : b)</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        pa[i] = pa[i - <span class="number">1</span>] + rnd[a[i - <span class="number">1</span>]], pb[i] = pb[i - <span class="number">1</span>] + rnd[b[i - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        cout &lt;&lt; (((pa[r1] - pa[l1 - <span class="number">1</span>]) == (pb[r2] - pb[l2 - <span class="number">1</span>]) &amp;&amp; r1 - l1 == r2 - l2) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h1><p>感谢 <a href="https://fjnuacm.top/user/661">@Floating-Ocean</a> 提供的练手题目！非常感谢！</p>
<h2 id="CF1996G"><a href="#CF1996G" class="headerlink" title="CF1996G"></a>CF1996G</h2><p>tbd.</p>
<h2 id="CF1977D"><a href="#CF1977D" class="headerlink" title="CF1977D"></a>CF1977D</h2><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目要求反转行后特殊列的最大数量。</p>
<p>如果 $(i,j)$ 是第 $j$ 列唯一一个 $1$ ，则除了第 $i$ 行以外，其他所有行第 $j$ 列为 $1$ 的要变换为 $0$，原本就是 $0$ 的不能变换。</p>
<p>也就是，确定 $grid[i][j]&#x3D;1$ 后，所有行的变换就固定了。</p>
<p>朴素的做法需要暴力统计，显然是不可能通过的。</p>
<p>但是，对于一种变换方案，他所产生的只有一个列是固定的，而对于列枚举其唯一位置的时候，变换方案也是固定的。他们之间有映射关系，于是可以用双哈希进行映射。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;i64&gt;&gt; <span class="built_in">randval</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;i64&gt;(<span class="number">3e5</span> + <span class="number">5</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;vec : randval)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : vec)</span><br><span class="line">            v = <span class="built_in">rng</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            grid[i][j] = s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, i64&gt;, <span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ind_ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        i64 sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            sum1 ^= grid[i][j] * randval[<span class="number">0</span>][i], sum2 ^= grid[i][j] * randval[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1 ^= randval[<span class="number">0</span>][i], sum2 ^= randval[<span class="number">1</span>][i];</span><br><span class="line">            ans[&#123;sum1, sum2&#125;]++;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; ans[&#123;sum1, sum2&#125;])</span><br><span class="line">                res = ans[&#123;sum1, sum2&#125;], ind_ans = &#123;j, i&#125;;</span><br><span class="line">            sum1 ^= randval[<span class="number">0</span>][i], sum2 ^= randval[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">inds</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (grid[i][ind_ans.first])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != ind_ans.second)</span><br><span class="line">                inds[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ind_ans.second == i)</span><br><span class="line">            inds[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; inds &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算竞学习笔记</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
        <tag>Trick</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 372 题解</title>
    <url>/2024-09-22-atcoder-abc-372.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,3675th,-2。</p>
<span id="more"></span>

<h1 id="A-Delete"><a href="#A-Delete" class="headerlink" title="A.Delete ."></a>A.Delete .</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串，非’.’输出即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : str)</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-3-A"><a href="#B-3-A" class="headerlink" title="B.3^A"></a>B.3^A</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>从高到低枚举pow(3,i)是否小于等于n，是则相减，易得构造出来的数列一定在20个以内。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (m)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">pow</span>(<span class="number">3</span>, i) &lt;= m)</span><br><span class="line">                m -= <span class="built_in">pow</span>(<span class="number">3</span>, i),ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : ans)</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Count-ABC-Again"><a href="#C-Count-ABC-Again" class="headerlink" title="C.Count ABC Again"></a>C.Count ABC Again</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>单个字符的修改最多会影响其字符-3到字符+3位置的ABC的数量，预处理后每次查询小规模暴力即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; str[i + <span class="number">2</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            pos.<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; idx &gt;&gt; ch;</span><br><span class="line">        idx--;</span><br><span class="line">        str[idx] = ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">0</span>, idx - <span class="number">4</span>); i &lt;= <span class="built_in">min</span>(n - <span class="number">3</span>, idx + <span class="number">4</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos.<span class="built_in">find</span>(i) != pos.<span class="built_in">end</span>() &amp;&amp; !(str[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; str[i + <span class="number">2</span>] == <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">                pos.<span class="built_in">erase</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (pos.<span class="built_in">find</span>(i) == pos.<span class="built_in">end</span>() &amp;&amp; (str[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; str[i + <span class="number">2</span>] == <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">                pos.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pos.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分。</strong></p>
<h1 id="D-Buildings"><a href="#D-Buildings" class="headerlink" title="D.Buildings"></a>D.Buildings</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>$O(N^2)$ 的暴力好实现，主要是如何优化时间复杂度使得答案不会TLE。</p>
<p>使用单调栈数据结构可以做到这点。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hs;</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(&#123;INT_MAX, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hs.second = i;</span><br><span class="line">        cin &gt;&gt; hs.first;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">top</span>().first &lt;= hs.first)</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        ans[st.<span class="built_in">top</span>().second]++;</span><br><span class="line">        ans[hs.second]--;</span><br><span class="line">        st.<span class="built_in">push</span>(hs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] + ans[i];</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="E-K-th-Largest-Connected-Components"><a href="#E-K-th-Largest-Connected-Components" class="headerlink" title="E.K-th Largest Connected Components"></a>E.K-th Largest Connected Components</h1><p>并查集维护每个节点的父节点，在父节点处维护前10大的子节点即可。</p>
<p>因为一开始没注意到 $k&#x3D;10 $ 所以TLE了好几发。赛后才过的。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">size_t</span>&gt; pa, size;</span><br><span class="line">    map&lt;<span class="type">size_t</span>, vector&lt;<span class="type">size_t</span>&gt;&gt; components;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">dsu</span><span class="params">(<span class="type">size_t</span> size_)</span> : pa(size_), size(size_, <span class="number">1</span>)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">iota</span>(pa.<span class="built_in">begin</span>(), pa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            components[i] = &#123;i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">size_t</span> x)</span> </span>&#123; <span class="keyword">return</span> pa[x] == x ? x : pa[x] = <span class="built_in">find</span>(pa[x]); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">size_t</span> x, <span class="type">size_t</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        pa[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(components[x]), greater&lt;&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(components[y]), greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(<span class="number">10</span>, (<span class="type">int</span>)components[x].<span class="built_in">size</span>()); i++)</span><br><span class="line">            n.<span class="built_in">push_back</span>(components[x][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(<span class="number">10</span>, (<span class="type">int</span>)components[y].<span class="built_in">size</span>()); i++)</span><br><span class="line">            n.<span class="built_in">push_back</span>(components[y][i]);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(n), greater&lt;&gt;());</span><br><span class="line">        components[x].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>((<span class="type">int</span>)n.<span class="built_in">size</span>(), <span class="number">10</span>); i++)</span><br><span class="line">            components[x].<span class="built_in">push_back</span>(n[i]);</span><br><span class="line">        components.<span class="built_in">erase</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">connected</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">dsu <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (op &amp; <span class="number">1</span>)</span><br><span class="line">            d.<span class="built_in">unite</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector res = d.<span class="built_in">connected</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() &gt;= b)</span><br><span class="line">                cout &lt;&lt; res[b - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>一些板子</title>
    <url>/2024-08-25-common-templates.html</url>
    <content><![CDATA[<p><strong>Obsidian</strong> 不知道为什么直接复制的板子总会有一些莫名其妙的零宽空格。还是放这里吧。</p>
<span id="more"></span>

<h1 id="Template-cpp"><a href="#Template-cpp" class="headerlink" title="Template.cpp"></a>Template.cpp</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">using</span> pgr = priority_queue&lt;_Tp, vector&lt;_Tp&gt;, greater&lt;&gt;&gt;;</span><br><span class="line"><span class="keyword">using</span> Point = complex&lt;<span class="type">int</span>&gt;; <span class="comment">// for geomentry use double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x real</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y imag</span></span><br><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>; <span class="comment">// usage:i64 x = rnd();</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) (a).begin(), (a).end()</span></span><br><span class="line"><span class="comment">// #define SINGLE</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SINGLE</span></span><br><span class="line">	t = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;程序执行用时 &quot;</span> &lt;&lt; <span class="number">1.0</span> * <span class="built_in">clock</span>() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; 秒。&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>模板：<a href="https://www.luogu.com.cn/problem/P1253">扶苏的问题</a></p>
<p>板子功能：懒惰标记(区间加和区间修改)，查询区间最大值，最小值，和值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    i64 w, s, m, t1, t2;</span><br><span class="line">    Node *ls, *rs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeModifyTag</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        w = t1 = x;</span><br><span class="line">        s = x * len;</span><br><span class="line">        m = t1 = x;</span><br><span class="line">        t2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeAddTag</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        w += x;</span><br><span class="line">        m += x;</span><br><span class="line">        s += len * x;</span><br><span class="line">        <span class="keyword">if</span> (t1 != LLONG_MAX)</span><br><span class="line">            t1 += x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t2 += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 != LLONG_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;<span class="built_in">makeModifyTag</span>(t1);</span><br><span class="line">            rs-&gt;<span class="built_in">makeModifyTag</span>(t1);</span><br><span class="line">            t1 = LLONG_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t2)</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;<span class="built_in">makeAddTag</span>(t2);</span><br><span class="line">            rs-&gt;<span class="built_in">makeAddTag</span>(t2);</span><br><span class="line">            t2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        w = <span class="built_in">max</span>(ls-&gt;w, rs-&gt;w);</span><br><span class="line">        m = <span class="built_in">min</span>(ls-&gt;m, rs-&gt;m);</span><br><span class="line">        s = ls-&gt;s + rs-&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InRange</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123; <span class="keyword">return</span> (L &lt;= l) &amp;&amp; (r &lt;= R); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OutofRange</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123; <span class="keyword">return</span> (l &gt; R) || (r &lt; L); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> x, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">makeModifyTag</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">makeAddTag</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            ls-&gt;<span class="built_in">update</span>(L, R, x, op);</span><br><span class="line">            rs-&gt;<span class="built_in">update</span>(L, R, x, op);</span><br><span class="line">            <span class="built_in">pushup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">i64 <span class="title">queryMax</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(ls-&gt;<span class="built_in">queryMax</span>(L, R), rs-&gt;<span class="built_in">queryMax</span>(L, R));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> LLONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">queryMin</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(ls-&gt;<span class="built_in">queryMin</span>(L, R), rs-&gt;<span class="built_in">queryMin</span>(L, R));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> LLONG_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">i64 <span class="title">querySum</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            <span class="keyword">return</span> ls-&gt;<span class="built_in">querySum</span>(L, R) + rs-&gt;<span class="built_in">querySum</span>(L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node Mem[MAXN &lt;&lt; <span class="number">1</span>], *pool = Mem;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">New</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> u = pool++;</span><br><span class="line">    u-&gt;l = L;</span><br><span class="line">    u-&gt;r = R;</span><br><span class="line">    u-&gt;t1 = LLONG_MAX;</span><br><span class="line">    u-&gt;t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L != R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        u-&gt;ls = <span class="built_in">New</span>(L, M);</span><br><span class="line">        u-&gt;rs = <span class="built_in">New</span>(M + <span class="number">1</span>, R);</span><br><span class="line">        u-&gt;<span class="built_in">pushup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        u-&gt;w = vec[L];</span><br><span class="line">        u-&gt;s = vec[L];</span><br><span class="line">        u-&gt;m = vec[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vec.<span class="built_in">resize</span>(n + <span class="number">1</span>); <span class="comment">// 从 1 开始算</span></span><br><span class="line">pool = Mem; <span class="comment">// 多测重置</span></span><br><span class="line"><span class="keyword">auto</span> root = <span class="built_in">New</span>(<span class="number">1</span>, n); <span class="comment">// 初始化根节点</span></span><br><span class="line">root-&gt;<span class="built_in">queryMax</span>(...);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带点权"><a href="#带点权" class="headerlink" title="带点权"></a>带点权</h3><p><strong>出现于24睿抗省赛，QLU24秋排第二场，第四场</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, <span class="number">0</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    value[s] = vec[s];</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[from] + weight &amp;&amp; value[to] &lt; value[from] + vec[to])</span><br><span class="line">            &#123;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分层图（以CF2014E为例）"><a href="#分层图（以CF2014E为例）" class="headerlink" title="分层图（以CF2014E为例）"></a>分层图（以CF2014E为例）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">using</span> pgr = priority_queue&lt;_Tp, vector&lt;_Tp&gt;, greater&lt;&gt;&gt;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, h, u, v, w;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; horse;</span><br><span class="line">vector&lt;vector&lt;i64&gt;&gt; dis, vis;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; edges;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> status;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> dis, <span class="type">int</span> from, <span class="type">bool</span> status) : <span class="built_in">dis</span>(dis), <span class="built_in">from</span>(from), <span class="built_in">status</span>(status) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">pgr&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis.<span class="built_in">assign</span>(<span class="number">2ll</span>, <span class="built_in">vector</span>&lt;i64&gt;(n + <span class="number">1ll</span>, LLONG_MAX / <span class="number">2</span>));</span><br><span class="line">    vis.<span class="built_in">assign</span>(<span class="number">2ll</span>, <span class="built_in">vector</span>&lt;i64&gt;(n + <span class="number">1ll</span>, <span class="literal">false</span>));</span><br><span class="line">    dis[<span class="number">0</span>][s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">0</span>, s, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [dist, from, status] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[status][from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[status][from] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="comment">// 已经骑马，这个点可以骑马和不能不能骑马，一共三种状态</span></span><br><span class="line">            <span class="keyword">if</span> (status)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[<span class="number">1</span>][to] &gt; dis[<span class="number">1</span>][from] + weight / <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[<span class="number">1</span>][to] = dis[<span class="number">1</span>][from] + weight / <span class="number">2</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(<span class="built_in">Node</span>(dis[<span class="number">1</span>][to], to, <span class="literal">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (horse[from])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[<span class="number">1</span>][to] &gt; dis[<span class="number">0</span>][from] + weight / <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[<span class="number">1</span>][to] = dis[<span class="number">0</span>][from] + weight / <span class="number">2</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(<span class="built_in">Node</span>(dis[<span class="number">1</span>][to], to, <span class="literal">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[<span class="number">0</span>][to] &gt; dis[<span class="number">0</span>][from] + weight)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[<span class="number">0</span>][to] = dis[<span class="number">0</span>][from] + weight;</span><br><span class="line">                    que.<span class="built_in">push</span>(<span class="built_in">Node</span>(dis[<span class="number">0</span>][to], to, <span class="literal">false</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算竞杂项</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
