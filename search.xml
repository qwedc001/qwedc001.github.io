<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>齐鲁工业大学ACM队内排位赛 2024秋季第一场 部分题解</title>
    <url>/2024-08-24-qluacm-rank-autumn-1.html</url>
    <content><![CDATA[<p><a href="https://icpc.qlu.edu.cn/training/664b4d4450be682a1fe01296">点我补题</a></p>
<p>竞赛结果：Solved ADGH。</p>
<span id="more"></span>


<h1 id="A-01"><a href="#A-01" class="headerlink" title="A.01"></a>A.01</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果 $0$ 或者 $1$ 有一个是偶数个，则一定可以通过操作将它们全部反转成另一个数字。所以只需要判断两个数字是否都是奇数个即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">count</span>(<span class="built_in">all</span>(str), <span class="string">&#x27;0&#x27;</span>) &amp; <span class="number">1</span> &amp;&amp; <span class="built_in">count</span>(<span class="built_in">all</span>(str), <span class="string">&#x27;1&#x27;</span>) &amp; <span class="number">1</span> ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-肥胖基因"><a href="#B-肥胖基因" class="headerlink" title="B.肥胖基因"></a>B.肥胖基因</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这不就是一个模拟查找。不知道为什么赛时写锅了只有80分。可恶。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(s1.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">substr</span>(i, m) == s2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; i + m; j++)</span><br><span class="line">                a[j]++;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="number">0</span> &amp;&amp; i &gt; temp) || temp == <span class="number">0</span>)</span><br><span class="line">                ans2++, temp = i + m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>)</span><br><span class="line">            ans1++;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-春游"><a href="#D-春游" class="headerlink" title="D.春游"></a>D.春游</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>暴力就能过。推数学公式还容易推出毛病来。注意 <code>int</code>范围不够。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    i64 ans = LLONG_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> big = <span class="number">0</span>;; big++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> rmd = <span class="built_in">max</span>(<span class="number">0ll</span>, n - big * <span class="number">49</span>);</span><br><span class="line">        <span class="type">int</span> small = (rmd / <span class="number">33</span>) + (rmd % <span class="number">33</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> money = big * <span class="number">3300</span> + small * <span class="number">1900</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, money);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">49</span> * big &gt; n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-找7"><a href="#G-找7" class="headerlink" title="G.找7"></a>G.找7</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>说起来你可能不信贫僧是用DFS过的。实际上 $k$ 的范围完全可以缩小到7，因为最坏的结果就是 <code>1+1+1+1+1+1+1</code>。所以再往上的 $k$ 都是吓唬人玩的。将所有数用 <code>map</code> 预处理一遍 mod 7 的结果就好了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> end, <span class="type">int</span> curpos, <span class="type">int</span> curval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curpos == end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (curval % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; idx;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                idx[d[i]]++;</span><br><span class="line">                <span class="keyword">if</span> (idx[d[i]] &gt; mp[d[i]].<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                curSum += mp[d[i]][idx[d[i]] - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[curpos] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(end, curpos + <span class="number">1</span>, curval + i);</span><br><span class="line">        d[curpos] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">        <span class="keyword">if</span> (vec[i] != <span class="number">0</span>)</span><br><span class="line">            mp[vec[i] % <span class="number">7</span>].<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(v));</span><br><span class="line">    <span class="keyword">if</span> (mp[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">        ans = mp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(k, <span class="number">7</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans == INT_MAX ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="H-路径"><a href="#H-路径" class="headerlink" title="H.路径"></a>H.路径</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>搜索入门题。是个签到。迷宫类题目真的是搜索必会了，判边界之类的。</p>
<p>然后我个人习惯用 <code>pair&lt;int,int&gt;</code>充当 <code>Point</code>，非常爽。可以用 <code>priority_queue</code>。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Point start, end;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">vec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(m));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (vec[i][j] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                start = &#123;i, j&#125;;</span><br><span class="line">            <span class="keyword">if</span> (vec[i][j] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                end = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, Point&gt;, vector&lt;pair&lt;<span class="type">int</span>, Point&gt;&gt;, greater&lt;&gt;&gt; que;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);</span><br><span class="line">    vis[start.x][start.y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [step, cur] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur == end)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, step);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : directions)</span><br><span class="line">        &#123;</span><br><span class="line">            Point nxt = &#123;dir.x + cur.x, dir.y + cur.y&#125;;</span><br><span class="line">            <span class="keyword">if</span> (nxt.x &gt;= <span class="number">0</span> &amp;&amp; nxt.x &lt; n &amp;&amp; nxt.y &gt;= <span class="number">0</span> &amp;&amp; nxt.y &lt; m &amp;&amp; !vis[nxt.x][nxt.y] &amp;&amp; vec[nxt.x][nxt.y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;vec[nxt.x][nxt.y] == <span class="string">&#x27;@&#x27;</span> ? step + <span class="number">3</span> : step + <span class="number">1</span>, nxt&#125;), vis[nxt.x][nxt.y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The End!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>待补：C，F，I</strong></p>
]]></content>
      <categories>
        <category>QLUOJ题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 368 题解</title>
    <url>/2024-08-24-atcoder-abc-368.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,3378th,Solved ABCD,+5</p>
<span id="more"></span>


<h1 id="A-Cut"><a href="#A-Cut" class="headerlink" title="A.Cut"></a>A.Cut</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $ 和一个数字 $k $ ，输出 $a[k],a[k+1],…,a[n],a[1],a[2],…a[k-1]$。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>直接 for 循环输出即可</li>
<li>使用 STL  <code>deque</code> （？）</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// deque</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, tmp;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        deq.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        deq.<span class="built_in">push_front</span>(deq.<span class="built_in">back</span>());</span><br><span class="line">        deq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!deq.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; deq.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>, deq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// for</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - k; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - k; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Decrease-2-max-elements"><a href="#B-Decrease-2-max-elements" class="headerlink" title="B.Decrease 2 max elements"></a>B.Decrease 2 max elements</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $，重复将数组降序排序，将前两个数字分别 -1，求几次后让整个数组最多只有一个正数</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="针对此题"><a href="#针对此题" class="headerlink" title="针对此题"></a>针对此题</h3><p>范围非常小，直接暴力就行。</p>
<h3 id="范围变大时候的更快解法"><a href="#范围变大时候的更快解法" class="headerlink" title="范围变大时候的更快解法"></a>范围变大时候的更快解法</h3><p>首先，每次操作 $\displaystyle\sum _ {i&#x3D;1} ^ NA _ i$ 都会减少 $2$ ，因此答案小于或等于 $\displaystyle\Biggl\lfloor\dfrac12\sum _ {i&#x3D;1} ^ NA _ i\Biggr\rfloor$ 。</p>
<p>接下来，由于每次操作中 $\displaystyle\max _ {1\leq i\leq N}A _ i$ 最多减少 $1$ ，因此 $\displaystyle\sum _ {i&#x3D;1} ^ NA _ i-\max _ {1\leq i\leq N}A _ i$ 在 $1$ 操作中减少 $1$ 或 $2$ ，结果小于或等于 $\displaystyle\sum _ {i&#x3D;1} ^ NA _ i-\max _ {1\leq i\leq N}A _ i$ 。</p>
<p>所以答案为$\displaystyle\min\Biggl\lbrace\Biggl\lfloor\dfrac12\sum _ {i&#x3D;1} ^ NA _ i\Biggr\rfloor,\sum _ {i&#x3D;1} ^ NA _ i-\max _ {1\leq i\leq N}A _ i\Biggr\rbrace$。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// brute</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; vec[i];</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(vec), greater&lt;&gt;());</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		vec[<span class="number">0</span>]--, vec[<span class="number">1</span>]--, cnt++;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(vec), greater&lt;&gt;());</span><br><span class="line">	&#125; <span class="keyword">while</span> (vec[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; vec[<span class="number">1</span>] &gt; <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// math</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		sum += a;</span><br><span class="line">		mx = <span class="built_in">max</span>(a, mx);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">min</span>(sum / <span class="number">2</span>, sum - mx) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Triple-Attack"><a href="#C-Triple-Attack" class="headerlink" title="C.Triple Attack"></a>C.Triple Attack</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $，每次对数组第一个数重复以下操作，当第一个数降到0及以下的时候将其移出数组：</p>
<ol>
<li>将数字减少1</li>
<li>将数字减少1</li>
<li>将数字减少3</li>
</ol>
<p>问几次操作后能置空整个数组。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>本题有坑。移出一个数字以后其操作次数是保留的，如果在移出头部数字的时候已经进行了前两步操作，那么可以直接对下一个数进行第三步操作。（吃了两发）</p>
<p>当第一个敌人的生命值达到 $5$ 或更高时，接下来的 $3$ 操作可以使第一个敌人的生命值减少 $5$ ，无论 $T$ 的当前值是多少。如果第一个敌人的生命值是 $H$ ，这组三个动作将重复 $\lfloor\frac{H}{5}\rfloor$ 组。通过一次性处理这部分并模拟即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	i64 cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		cnt += a / <span class="number">5</span> * <span class="number">3</span>;</span><br><span class="line">		a %= <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">while</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">				a -= <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				a--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Minimum-Steiner-Tree"><a href="#D-Minimum-Steiner-Tree" class="headerlink" title="D.Minimum Steiner Tree"></a>D.Minimum Steiner Tree</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一颗 $n$ 个节点， $n-1$ 条边的树，给出 $k$ 个节点，找到连接这 $k$ 个节点的最小联通块的大小。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>带路径染色的DFS。用 <code>vector &lt;bool&gt;</code> 存一下被染色的路径点和需要找到的 $k$ 个节点即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[start] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> edge : edges[start])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[edge] &amp;&amp; <span class="built_in">dfs</span>(edge))</span><br><span class="line">			vec[start] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[start] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (vec[start])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		edges[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		edges[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">			start = tmp;</span><br><span class="line">		vec[tmp] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(start);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">count</span>(<span class="built_in">all</span>(vec), <span class="literal">true</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分</strong></p>
<h1 id="F-Dividing-Game"><a href="#F-Dividing-Game" class="headerlink" title="F.Dividing Game"></a>F.Dividing Game</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入一个数组 $ a[1],a[2],…,a[n] $，<code>Anna</code> 和 <code>Bruno</code> 轮流选取其中的数字 $a[i]$ ，并且将 $a[i]$ 替换为其任意一个非自己的因数。不能进行此操作的玩家输掉比赛。问谁会赢。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>Nim 游戏中的 SG 函数。<a href="https://oi.wiki/math/game-theory/impartial-game/#%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F%E4%B8%8E-sg-%E5%87%BD%E6%95%B0">参考资料（OI WIKI）</a>，<a href="https://www.luogu.com.cn/article/shyocttb">参考资料2（洛谷博客，SG函数精讲）</a>。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="type">int</span> m = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a[i], m = <span class="built_in">max</span>(m, a[i]);</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">d</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= m; j += i)</span><br><span class="line">			d[j].<span class="built_in">push_back</span>(i); <span class="comment">// 因数</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sg</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= m; x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k = d[x].<span class="built_in">size</span>();</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y : d[x])</span><br><span class="line">			<span class="keyword">if</span> (sg[y] &lt;= k)</span><br><span class="line">				cnt[sg[y]]++;</span><br><span class="line">		<span class="keyword">while</span> (cnt[sg[x]] &gt; <span class="number">0</span>)</span><br><span class="line">			sg[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		ans ^= sg[a[i]];</span><br><span class="line">	cout &lt;&lt; (ans &gt; <span class="number">0</span> ? <span class="string">&quot;Anna&quot;</span> : <span class="string">&quot;Bruno&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Add-and-Multiply-Queries"><a href="#G-Add-and-Multiply-Queries" class="headerlink" title="G.Add and Multiply Queries"></a>G.Add and Multiply Queries</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>输入两个数组 $ a[1],a[2],…,a[n] 和 b[1],b[2],…,b[n] $，给定 $q$ 组如下格式的询问：</p>
<p><code>1 i x</code>：将 $a[i]$ 的值改为 $x$。</p>
<p><code>2 i x</code>：将 $b[i]$ 的值改为 $x$。</p>
<p><code>3 l r</code>： 设定 $v&#x3D;0$，对于区间 $[l,r]$ ，将 $v$ 替换为 $v+a[i]$ 或者 $v*b[i]$，求最大的 $v$。</p>
<p><strong>保证操作3的答案最高为$10^{18}$。</strong></p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>因为保证了操作3有答案上限，则数组 $b$ 中超过 $1$ 的个数不会大于 $60$ 个 ($2^{60} &gt; 10^{18}$)。</p>
<p>用树状数组维护 $a$，用 $set$ 维护 $b[i] &gt; 1$ 的 $i$。然后查找区间内有没有大于 $1$ 的数，并且判断两种操作哪种最优即可。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	vector&lt;i64&gt; tr;</span><br><span class="line">	<span class="built_in">Fenwick</span>(vector&lt;i64&gt; &amp;vec)</span><br><span class="line">	&#123;</span><br><span class="line">		n = vec.<span class="built_in">size</span>();</span><br><span class="line">		tr.<span class="built_in">resize</span>(N);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">update_add</span>(i, vec[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &amp; -x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update_add</span><span class="params">(<span class="type">int</span> x, i64 val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">			tr[i] += val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update_sub</span><span class="params">(<span class="type">int</span> x, i64 val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">update_add</span>(x, -val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">i64 <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		i64 res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">			res += tr[i];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;i64&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="function">Fenwick <span class="title">tree</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; b[i];</span><br><span class="line">		<span class="keyword">if</span> (b[i] &gt; <span class="number">1</span>)</span><br><span class="line">			st.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> op, l, r;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tree.<span class="built_in">update_sub</span>(l, a[l]);</span><br><span class="line">			a[l] = r;</span><br><span class="line">			tree.<span class="built_in">update_add</span>(l, a[l]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (b[l] &gt; <span class="number">1</span>)</span><br><span class="line">				st.<span class="built_in">erase</span>(l);</span><br><span class="line">			b[l] = r;</span><br><span class="line">			<span class="keyword">if</span> (b[l] &gt; <span class="number">1</span>)</span><br><span class="line">				st.<span class="built_in">insert</span>(l);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i64 v = a[l];</span><br><span class="line">			l = l + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> it = st.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">				<span class="keyword">if</span> (it == st.<span class="built_in">end</span>() || *it &gt; r)</span><br><span class="line">				&#123;</span><br><span class="line">					v += tree.<span class="built_in">query</span>(r) - tree.<span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				v += tree.<span class="built_in">query</span>(*it - <span class="number">1</span>) - tree.<span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">				v = <span class="built_in">max</span>(v * b[*it], v + a[*it]);</span><br><span class="line">				l = *it + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Train-Delay"><a href="#E-Train-Delay" class="headerlink" title="E.Train Delay"></a>E.Train Delay</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>$n$ 个城市，$m$ 条火车，第 $i$ 条 从 $a[i]$ 城市在 $s[i]$ 时刻出发，到达 $b[i]$ 城市的时刻为 $t[i]$。</p>
<p>现在第一条线路的火车晚点了 $x[1]$ 分钟，为了让任意一组本来可以换乘的火车仍能换乘，需要对其他的所有火车进行晚点（也可以不晚点）。<br>找出从第 $2$ 辆到第 $m$ 辆火车，每辆火车最少需要晚点多长时间。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p><code>I don&#39;t know how to write dp I am dp 低手</code>。</p>
<p>以下代码是 <code>jiangly</code> 的。大概思路还要梳理一下。可以参考一下Atcoder Editorial的思路。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> N, M, X0;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M &gt;&gt; X0;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(M)</span>, <span class="title">B</span><span class="params">(M)</span>, <span class="title">S</span><span class="params">(M)</span>, <span class="title">T</span><span class="params">(M)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; A[i] &gt;&gt; B[i] &gt;&gt; S[i] &gt;&gt; T[i];</span><br><span class="line">		A[i]--, B[i]--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">e</span>(<span class="number">2</span> * M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		e[<span class="number">2</span> * i] = &#123;S[i], <span class="number">1</span>, i&#125;;</span><br><span class="line">		e[<span class="number">2</span> * i + <span class="number">1</span>] = &#123;T[i], <span class="number">0</span>, i&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(M)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tm</span><span class="params">(N)</span></span>;</span><br><span class="line">	X[<span class="number">0</span>] = X0;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [t, o, i] : e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="number">1</span>)</span><br><span class="line">			X[i] = <span class="built_in">max</span>(X[i], tm[A[i]] - S[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tm[B[i]] = <span class="built_in">max</span>(tm[B[i]], T[i] + X[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">		cout &lt;&lt; X[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>一些板子</title>
    <url>/2024-08-25-common-templates.html</url>
    <content><![CDATA[<p><strong>Obsidian</strong> 不知道为什么直接复制的板子总会有一些莫名其妙的零宽空格。还是放这里吧。</p>
<span id="more"></span>


<h1 id="Template-cpp"><a href="#Template-cpp" class="headerlink" title="Template.cpp"></a>Template.cpp</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) (a).begin(), (a).end()</span></span><br><span class="line"><span class="comment">// #define SINGLE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SINGLE</span></span><br><span class="line">	t = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;程序执行用时 &quot;</span> &lt;&lt; <span class="number">1.0</span> * <span class="built_in">clock</span>() / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; 秒。&quot;</span> &lt;&lt; endl; <span class="comment">// 注意此行在 domjudge 里可能会引起 RE，在 cf 和 atcoder 不会</span></span><br><span class="line">	<span class="comment">//而且启用这行 cerr 要在 cph 里关掉检测到 stderr 就报错的选项</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>模板：<a href="https://www.luogu.com.cn/problem/P1253">扶苏的问题</a></p>
<p>板子功能：懒惰标记(区间加和区间修改)，查询区间最大值，最小值，和值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    i64 w, s, m, t1, t2;</span><br><span class="line">    Node *ls, *rs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeModifyTag</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        w = t1 = x;</span><br><span class="line">        s = x * len;</span><br><span class="line">        m = t1 = x;</span><br><span class="line">        t2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeAddTag</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">this</span>-&gt;r - <span class="keyword">this</span>-&gt;l + <span class="number">1</span>;</span><br><span class="line">        w += x;</span><br><span class="line">        m += x;</span><br><span class="line">        s += len * x;</span><br><span class="line">        <span class="keyword">if</span> (t1 != LLONG_MAX)</span><br><span class="line">            t1 += x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t2 += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 != LLONG_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;<span class="built_in">makeModifyTag</span>(t1);</span><br><span class="line">            rs-&gt;<span class="built_in">makeModifyTag</span>(t1);</span><br><span class="line">            t1 = LLONG_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t2)</span><br><span class="line">        &#123;</span><br><span class="line">            ls-&gt;<span class="built_in">makeAddTag</span>(t2);</span><br><span class="line">            rs-&gt;<span class="built_in">makeAddTag</span>(t2);</span><br><span class="line">            t2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        w = <span class="built_in">max</span>(ls-&gt;w, rs-&gt;w);</span><br><span class="line">        m = <span class="built_in">min</span>(ls-&gt;m, rs-&gt;m);</span><br><span class="line">        s = ls-&gt;s + rs-&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InRange</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123; <span class="keyword">return</span> (L &lt;= l) &amp;&amp; (r &lt;= R); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OutofRange</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123; <span class="keyword">return</span> (l &gt; R) || (r &lt; L); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> x, <span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">makeModifyTag</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">makeAddTag</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            ls-&gt;<span class="built_in">update</span>(L, R, x, op);</span><br><span class="line">            rs-&gt;<span class="built_in">update</span>(L, R, x, op);</span><br><span class="line">            <span class="built_in">pushup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">i64 <span class="title">queryMax</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(ls-&gt;<span class="built_in">queryMax</span>(L, R), rs-&gt;<span class="built_in">queryMax</span>(L, R));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> LLONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">queryMin</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(ls-&gt;<span class="built_in">queryMin</span>(L, R), rs-&gt;<span class="built_in">queryMin</span>(L, R));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> LLONG_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">i64 <span class="title">querySum</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">InRange</span>(L, R))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">OutofRange</span>(L, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushdown</span>();</span><br><span class="line">            <span class="keyword">return</span> ls-&gt;<span class="built_in">querySum</span>(L, R) + rs-&gt;<span class="built_in">querySum</span>(L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node Mem[MAXN &lt;&lt; <span class="number">1</span>], *pool = Mem;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">New</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> u = pool++;</span><br><span class="line">    u-&gt;l = L;</span><br><span class="line">    u-&gt;r = R;</span><br><span class="line">    u-&gt;t1 = LLONG_MAX;</span><br><span class="line">    u-&gt;t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L != R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        u-&gt;ls = <span class="built_in">New</span>(L, M);</span><br><span class="line">        u-&gt;rs = <span class="built_in">New</span>(M + <span class="number">1</span>, R);</span><br><span class="line">        u-&gt;<span class="built_in">pushup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        u-&gt;w = vec[L];</span><br><span class="line">        u-&gt;s = vec[L];</span><br><span class="line">        u-&gt;m = vec[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vec.<span class="built_in">resize</span>(n + <span class="number">1</span>); <span class="comment">// 从 1 开始算</span></span><br><span class="line">pool = Mem; <span class="comment">// 多测重置</span></span><br><span class="line"><span class="keyword">auto</span> root = <span class="built_in">New</span>(<span class="number">1</span>, n); <span class="comment">// 初始化根节点</span></span><br><span class="line">root-&gt;<span class="built_in">queryMax</span>(...);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带点权"><a href="#带点权" class="headerlink" title="带点权"></a>带点权</h3><p><strong>出现于24睿抗省赛，QLU24秋排第二场，第四场</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, <span class="number">0</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    value[s] = vec[s];</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[from] + weight &amp;&amp; value[to] &lt; value[from] + vec[to])</span><br><span class="line">            &#123;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算竞杂项</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>齐鲁工业大学ACM队内排位赛 2024秋季第二场 题解</title>
    <url>/2024-08-25-qluacm-rank-autumn-2.html</url>
    <content><![CDATA[<p><a href="https://icpc.qlu.edu.cn/training/664b4d4450be682a1fe01296">点我补题</a></p>
<p>竞赛结果：Solved ABCEFG。</p>
<span id="more"></span>


<h1 id="A-好朋友"><a href="#A-好朋友" class="headerlink" title="A.好朋友"></a>A.好朋友</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从 $x$ 处出发，分别向左右两侧找最近的房子并且计算距离即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; m;</span><br><span class="line">    x--;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    <span class="type">int</span> lft = INT_MAX, rt = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; lft == INT_MAX; i--)</span><br><span class="line">        <span class="keyword">if</span> (vec[i] != <span class="number">0</span> &amp;&amp; vec[i] &lt;= m)</span><br><span class="line">            lft = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; n &amp;&amp; rt == INT_MAX; i++) </span><br><span class="line">        <span class="keyword">if</span> (vec[i] != <span class="number">0</span> &amp;&amp; vec[i] &lt;= m)</span><br><span class="line">            rt = i;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(<span class="built_in">abs</span>(lft - x), <span class="built_in">abs</span>(rt - x)) * <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="B-三元组"><a href="#B-三元组" class="headerlink" title="B.三元组"></a>B.三元组</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>记录每个数字出现的下标，然后对于数组中每一个数字 $a[i]$ ，二分查找其左侧的 $a[i]+1$ 和右侧的 $a[i]+1$。并且用 <code>distance</code> STL 来计算还存在几个下标符合要求，相乘即可。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i], pos[vec[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> search = pos[vec[i] + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> lft = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(search), i);</span><br><span class="line">        <span class="keyword">if</span> (lft != search.<span class="built_in">end</span>())</span><br><span class="line">            ans += <span class="built_in">distance</span>(search.<span class="built_in">begin</span>(), lft) * <span class="built_in">distance</span>(lft, search.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="C-平分苹果"><a href="#C-平分苹果" class="headerlink" title="C.平分苹果"></a>C.平分苹果</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>赛时写了个特别难绷的模拟。</p>
<p>赛后队友点了一下发现，<strong>不进位的二进制加法 &#x3D;&#x3D; 异或。</strong></p>
<p>于是就成水题了。</p>
<p>只要异或起来不等于0，无解。否则和减去最小值即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, sum = <span class="number">0</span>, mn = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i], sum += vec[i], mn = <span class="built_in">min</span>(mn, vec[i]), x ^= vec[i];</span><br><span class="line">    cout &lt;&lt; (x ? <span class="number">-1</span> : sum - mn) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="D-套餐"><a href="#D-套餐" class="headerlink" title="D.套餐"></a>D.套餐</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>背包 dp，还是个二维的。</p>
<p><code>I don&#39;t know how to write dp I am dp 低手</code>。</p>
<p>（大雾）</p>
<p>对于第 $a[i]$ 个食物组， 有 $dp[j][k] &#x3D; min(dp[j][k], dp[max(0, j - a[i].first)][max(0, k - a[i].second)] + 1)$，跑一遍取从 $dp[x][y]$ 到 $dp[N][N]$ 的最小值就行了。</p>
<p>二维背包要跑三次 $for$ ，记好了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, ft, sd, sum1, sum2;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a[<span class="number">305</span>];</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">305</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">305</span>, INT_MAX - <span class="number">1e4</span>));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; ft &gt;&gt; sd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">        sum1 += a[i].first, sum2 += a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum1 &lt; ft || sum2 &lt; sd)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">300</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">300</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">                    dp[j][k] = <span class="built_in">min</span>(dp[j][k], dp[<span class="built_in">max</span>(<span class="number">0</span>, j - a[i].first)][<span class="built_in">max</span>(<span class="number">0</span>, k - a[i].second)] + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX - <span class="number">1e4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ft; i &lt;= <span class="number">300</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = sd; j &lt;= <span class="number">300</span>; j++)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i][j]);</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="E-取球"><a href="#E-取球" class="headerlink" title="E.取球"></a>E.取球</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>用队列模拟并且每次在出队一对球以后将新队首再次记录即可，麻烦一点的小模拟。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bar</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> ball;</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">            cin &gt;&gt; ball, bar[i].<span class="built_in">push</span>(ball);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; ontop_idx;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; both;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ball = bar[i].<span class="built_in">front</span>();</span><br><span class="line">        ontop_idx[ball].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (ontop_idx[ball].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">            both.<span class="built_in">push</span>(ball);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!both.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ball = both.<span class="built_in">front</span>();</span><br><span class="line">        both.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> idx = ontop_idx[ball][i];</span><br><span class="line">            bar[idx].<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!bar[idx].<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cur_top = bar[idx].<span class="built_in">front</span>();</span><br><span class="line">                ontop_idx[cur_top].<span class="built_in">push_back</span>(idx);</span><br><span class="line">                <span class="keyword">if</span> (ontop_idx[cur_top].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">                    both.<span class="built_in">push</span>(cur_top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : bar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!it.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="F-航班"><a href="#F-航班" class="headerlink" title="F.航班"></a>F.航班</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>带点权的 <code>dijkstra</code>。可以在板子里找到对应的模板。注意 $N$ 的大小。</p>
<p>哦本题需要缓存一下结果防止爆TLE。没有其他问题了。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, <span class="number">0</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    value[s] = vec[s];</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[from] + weight &amp;&amp; value[to] &lt; value[from] + vec[to])</span><br><span class="line">            &#123;</span><br><span class="line">                value[to] = value[from] + vec[to];</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">grid</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; grid[i];</span><br><span class="line">        grid[i] = <span class="string">&#x27;#&#x27;</span> + grid[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                edges[i].<span class="built_in">push_back</span>(&#123;j, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res_dis</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res_val</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, i);</span><br><span class="line">        res_dis[i] = dis;</span><br><span class="line">        res_val[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from, to;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">        <span class="keyword">if</span> (res_dis[from][to] == INT_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; res_dis[from][to] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res_val[from][to] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="G-商品"><a href="#G-商品" class="headerlink" title="G.商品"></a>G.商品</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>可以 <code>dp</code> ，但是有没有不 <code>dp</code> 也能过的思路。</p>
<p>有的，优先队列处理一下就行了。</p>
<p>记录每个物品的保质期，按照保质期倒序排序，在第 $day[i+1]$ 到 $day[i]$ 天的时间段内只有保质期到 $day[i+1]$ 的商品可供售卖，将他们扔到一个池子里按照价值排序即可。排序这块用 <code>priority_queue</code> 就完全OK。</p>
<p>本题输入逻辑比较逆天，所以 $n$ 放在了主函数而非 <code>solve</code> 里。注意一下。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; days;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p, d;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; d;</span><br><span class="line">        mp[d].<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">        days.<span class="built_in">push_back</span>(k);</span><br><span class="line">    days.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pool;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; days.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = days[i - <span class="number">1</span>] - days[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : mp[days[i - <span class="number">1</span>]])</span><br><span class="line">            pool.<span class="built_in">push</span>(v);</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &amp;&amp; !pool.<span class="built_in">empty</span>())</span><br><span class="line">            ans += pool.<span class="built_in">top</span>(), pool.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2024ACM集训队第一次入队赛 验题人题解</title>
    <url>/2024-08-31-2024-newbie-1-coord-tutorial.html</url>
    <content><![CDATA[<p><a href="https://icpc.qlu.edu.cn/training/6648cfa00ee9c1c358afe5f3">点我补题</a></p>
<span id="more"></span>

<h1 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h1><p>我的代码有一个最基本的多测架构，具体架构可以参照<a href="https://qwedc001.github.io/2024-08-25-common-templates.html">板子博客记录</a>的 Template.cpp 章节。对于多测场景，在 <code>main</code>函数里负责读入数据组数，并且在 <code>solve</code>函数里负责每一个单测的解题，这是一种比较好的习惯。在下面的题解代码中，我只会给出每一个单测的 solve 函数。不再赘述。</p>
<h1 id="A-网络竞赛平台与小鹿与正在检验你是否是真人请稍后"><a href="#A-网络竞赛平台与小鹿与正在检验你是否是真人请稍后" class="headerlink" title="A.网络竞赛平台与小鹿与正在检验你是否是真人请稍后"></a>A.网络竞赛平台与小鹿与正在检验你是否是真人请稍后</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以开一个桶记录从 0 到 9 每一位在输入数字中出现了多少次。题目要求没有前导 0，则首位肯定要从 1~9 中最小的一个数字出。然后就是从 0 到 9 依次输出即可。</p>
<p>针对于我的验题代码：我采用了字符串读入并遍历字符串来快速检索每一位的值（而不是每次%10 记录完后&#x2F;10），并且采用了 map 代替堆来进行遍历。</p>
<h2 id="代码（验题程序）"><a href="#代码（验题程序）" class="headerlink" title="代码（验题程序）"></a>代码（验题程序）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[ch - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(mn + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    mp[mn]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">        <span class="keyword">while</span> (v)</span><br><span class="line">            v--, ans.<span class="built_in">push_back</span>(k + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码（新手友好版本）"><a href="#代码（新手友好版本）" class="headerlink" title="代码（新手友好版本）"></a>代码（新手友好版本）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[num % <span class="number">10</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, num % <span class="number">10</span>);</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mn;</span><br><span class="line">    cnt[mn]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt[i] &gt; <span class="number">0</span>)</span><br><span class="line">            cnt[i]--, cout &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-ICPC-与小鹿的差旅费用规划"><a href="#B-ICPC-与小鹿的差旅费用规划" class="headerlink" title="B.ICPC 与小鹿的差旅费用规划"></a>B.ICPC 与小鹿的差旅费用规划</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>签到。输入 $a,b$ ，输出 $2a+b$。</p>
<p><strong>但是</strong>，很多人做题的时候，一个是不明白多测的具体含义（这个我给出的样例也有锅，我谢罪），上来直接开写。</p>
<p>另外一些人则是做题不看数据范围，或者是不知道给出数据范围是<strong>干什么用的</strong>，这就不好。</p>
<p>在 C++中，int 变量在记录的时候，其上限能记录到 32 位二进制均为 1 的数字，也就是十进制的大约$2\cdot10^9$。而题目中给出的数据范围在 $2\cdot10^{15}$，明显超出此范围。</p>
<p>所以，要用 <code>long long</code>。</p>
<p>十年算竞一场空，不开 <code>long long</code>见祖宗。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a * <span class="number">2</span> + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-CCPC-与饭后消食的小鹿"><a href="#C-CCPC-与饭后消食的小鹿" class="headerlink" title="C.CCPC 与饭后消食的小鹿"></a>C.CCPC 与饭后消食的小鹿</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>本题为 <a href="https://atcoder.jp/contests/abc240/tasks/abc240_c">Atcoder Beginner Contest 240 C 题原题</a>，并且数据点也是直接采用的 Atcoder 公开的数据点。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>小鹿每次跳跃都会从上一次发展而来，所以我们可以维护两个数组，一个用来记录“上一次跳跃”所到达的点，一个根据“上一次跳跃”到达的点计算本次跳跃到达的新点，然后每次计算完成后，用本次跳跃到达的点的数据覆盖上一次跳跃到达的点。数据范围足够小，不会超时。</p>
<p>思考题：这道题正解是动态规划，怎么样优化才能将暴力代码优化成动态规划的样子？动态规划是什么？</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> last[<span class="number">10200</span>];</span><br><span class="line">    <span class="type">int</span> cur[<span class="number">10200</span>];</span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    last[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cur[i + a] = <span class="number">1</span>;</span><br><span class="line">                cur[i + b] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            last[i] = cur[i];</span><br><span class="line">            cur[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last[x])</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-百度之星与小鹿的铁牌"><a href="#D-百度之星与小鹿的铁牌" class="headerlink" title="D.百度之星与小鹿的铁牌"></a>D.百度之星与小鹿的铁牌</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这个需要在纸上自行模拟一下路线，也就是为什么ACM竞赛会提供草稿纸。有些数学题不动笔墨是想不到做题思路的。</p>
<p>模拟路线个数以后可以很轻易的发现，从 $1$ 到 $n$ 的路径个数符合斐波那契数列规律，问题转化为求前30项斐波那契数列。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fib[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 需要先在 main 函数里执行一次 init</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>, fib[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; fib[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-蓝桥杯与鹿与小面包"><a href="#E-蓝桥杯与鹿与小面包" class="headerlink" title="E.蓝桥杯与鹿与小面包"></a>E.蓝桥杯与鹿与小面包</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>智慧题。题目要求删除若干组数以后恰好留下一个最大的数，我们逆过来考虑，有哪些数被删除以后可以留下。</p>
<p>当一个数左侧有 $n\cdot k$个数的时候，其右侧也一定有 $m \cdot k$ 个数 $(n,m &gt; 0)$，因为题目保证经过删除数字操作以后恰好只剩下一个数。</p>
<p>所以只需要计算满足条件的数字的最大值即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> num, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span> ((i - <span class="number">1</span>) % k == <span class="number">0</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, num);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="F-睿抗与小鹿的贪心消消乐"><a href="#F-睿抗与小鹿的贪心消消乐" class="headerlink" title="F.睿抗与小鹿的贪心消消乐"></a>F.睿抗与小鹿的贪心消消乐</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>模拟。按部就班的写，注意判断特殊情况（比如三个格子相邻且都是万能颜色 <code>.</code>）即可。</p>
<p>考验代码底力的题目。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">grid</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; grid[i], grid[i] = <span class="string">&#x27;$&#x27;</span> + grid[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;Point&gt; <span class="title">vec</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; xs, ys;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; vec[i].x &gt;&gt; vec[i].y;</span><br><span class="line">                xs.<span class="built_in">push_back</span>(vec[i].x), ys.<span class="built_in">push_back</span>(vec[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(xs.<span class="built_in">begin</span>(), xs.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>());</span><br><span class="line">            set&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">            <span class="keyword">if</span> (xs[<span class="number">0</span>] == xs[<span class="number">1</span>] &amp;&amp; xs[<span class="number">1</span>] == xs[<span class="number">2</span>] &amp;&amp; ys[<span class="number">1</span>] - ys[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; ys[<span class="number">2</span>] - ys[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pt : vec)</span><br><span class="line">                    <span class="keyword">if</span> (grid[pt.x][pt.y] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(grid[pt.x][pt.y]);</span><br><span class="line">                cout &lt;&lt; (st.<span class="built_in">size</span>() &lt;= <span class="number">1</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ys[<span class="number">0</span>] == ys[<span class="number">1</span>] &amp;&amp; ys[<span class="number">1</span>] == ys[<span class="number">2</span>] &amp;&amp; xs[<span class="number">1</span>] - xs[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; xs[<span class="number">2</span>] - xs[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pt : vec)</span><br><span class="line">                    <span class="keyword">if</span> (grid[pt.x][pt.y] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        st.<span class="built_in">insert</span>(grid[pt.x][pt.y]);</span><br><span class="line">                cout &lt;&lt; (st.<span class="built_in">size</span>() &lt;= <span class="number">1</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Point pt;</span><br><span class="line">            <span class="type">char</span> val;</span><br><span class="line">            cin &gt;&gt; pt.x &gt;&gt; pt.y &gt;&gt; val;</span><br><span class="line">            grid[pt.x][pt.y] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="G-天梯赛与小鹿与字符串维护"><a href="#G-天梯赛与小鹿与字符串维护" class="headerlink" title="G.天梯赛与小鹿与字符串维护"></a>G.天梯赛与小鹿与字符串维护</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>另一道模拟题。也是按部就班的模拟就好了，需要一定字符串知识。</p>
<p>如果看不懂题解代码，请先学习完C++的string字符串部分再来补题。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            str += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">                ans += val[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="built_in">assert</span>(r &lt;= str.<span class="built_in">size</span>());</span><br><span class="line">            str = str.<span class="built_in">substr</span>(<span class="number">0</span>, l - <span class="number">1</span>) + str.<span class="built_in">substr</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="Fun-Facts"><a href="#Fun-Facts" class="headerlink" title="Fun Facts"></a>Fun Facts</h1><p>1.本套题目的主人公是教练鹿老师的儿子，他现在也是一名信息竞赛选手。当然，我们事先在出题的时候没有告诉鹿老师，所以他在看到题面的时候乐了好一阵。</p>
<p>2.所有的比赛背景介绍由我撰写。包括梗图也是我找的，看着感觉是不是还不错。</p>
<p>3.一开始想要拿一道大模拟做最难的题，并且一开始想要放在 A 题的位置。但是我们担心大家都不会写，最后取消了，放了个比较简单的题在 A 的位置上。</p>
<p>4.A 题想要教会大家两件事：题目难度与顺序无关，题目背景与题目无关。</p>
<p>5.消消乐题目经过了一次数据削弱，但是削弱后的随机数据卡掉了我的验题程序。（削弱后随机数据随机出了 <code>...</code> 数据，这组数据成功卡掉了半数验题人的答案）</p>
<p>6.榜单的颜色不仅是想要对应彩虹色，比如青绿色和青蓝色对应言和和洛天依的弹幕应援色。所有的颜色都有对应的 VOCALOID 应援色，当然是我自己搞的。看看有没有有心人能收集全。（？</p>
<p>7.想要看大家比赛结果的我过于热切，于是物理补考只写了 30 分钟就匆匆交卷跑路了（？？）</p>
<p>8.感谢所有集训队成员为新生赛做出的努力！</p>
]]></content>
      <categories>
        <category>QLUOJ题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 369 题解</title>
    <url>/2024-09-06-atcoder-abc-369.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,4815th,Solved ABD,-14</p>
<ol>
<li>博主忘了写补题博客了</li>
<li>本场进行时正在线下进行新生赛后台，打的不好。C题居然没想出来。</li>
<li>因为是补作，时间比较紧迫不再提供题目大意，下场恢复，这场择期补上[TODO]</li>
<li>FG还需要进一步梳理[TODO]</li>
</ol>
<span id="more"></span>

<h1 id="A-369"><a href="#A-369" class="headerlink" title="A.369"></a>A.369</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力求解即可。为了保险把范围开的大了一点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10000</span>; i &gt;= <span class="number">-10000</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        vector vec = &#123;a, b, i&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="number">2</span>] - vec[<span class="number">1</span>] == vec[<span class="number">1</span>] - vec[<span class="number">0</span>])</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Piano-3"><a href="#B-Piano-3" class="headerlink" title="B.Piano 3"></a>B.Piano 3</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>将左手初始放在第一个左手音符上，右手初始放在第一个右手音符上，所得解法就是最佳解法。因为你需要按顺序处理每只手的音符。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            L.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; L.<span class="built_in">size</span>(); i++)</span><br><span class="line">        fat += <span class="built_in">abs</span>(L[i - <span class="number">1</span>] - L[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; R.<span class="built_in">size</span>(); i++)</span><br><span class="line">        fat += <span class="built_in">abs</span>(R[i - <span class="number">1</span>] - R[i]);</span><br><span class="line">    cout &lt;&lt; fat &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Count-Arithmetic-Subarrays"><a href="#C-Count-Arithmetic-Subarrays" class="headerlink" title="C.Count Arithmetic Subarrays"></a>C.Count Arithmetic Subarrays</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>从左到右遍历，找到不符合等差数列关系的分割点后记录，计算 $\sum{\frac{x*(x+1)}{2}}$。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](i64 n)</span><br><span class="line">    &#123; <span class="keyword">return</span> n * (n + <span class="number">1</span>) / <span class="number">2</span>; &#125;;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i : vec)</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">    i64 ans = n;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] - vec[i - <span class="number">1</span>] != vec[i + <span class="number">1</span>] - vec[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">f</span>(i - pre);</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">f</span>(n - <span class="number">1</span> - pre);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="D-Bonus-EXP"><a href="#D-Bonus-EXP" class="headerlink" title="D.Bonus EXP"></a>D.Bonus EXP</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>状态转移的dp，可以证明不会跳过相邻的两只怪物，否则解法必然不是最优。</p>
<p>设 $dp[2][n]$，$dp[0]$ 表示杀敌为奇数，$dp[1]$ 表示杀敌数为偶数，然后在两者之间进行转移即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    vector&lt;vector&lt;i64&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;i64&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = vec[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="built_in">max</span>(dp[<span class="number">0</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][i - <span class="number">1</span>] + vec[i]);</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="built_in">max</span>(dp[<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][i - <span class="number">1</span>] + (<span class="number">2</span> * vec[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[<span class="number">0</span>][n], dp[<span class="number">1</span>][n]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分</strong></p>
<h1 id="E-Sightseeing-Tour"><a href="#E-Sightseeing-Tour" class="headerlink" title="E.Sightseeing Tour"></a>E.Sightseeing Tour</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>数据足够小，这题用什么寻路算法都可以，跑一遍两点之间最短路以后，用DFS将所有可能出现的点与点的连接方式跑一遍（枚举所有出现方式用全排列，数据范围够小可以跑的开），求 $ min $ 即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, from;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> dis &gt; a.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(MAXN)</span>, <span class="title">vis</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, INT_MAX);</span><br><span class="line">    vis = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN, <span class="number">0</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> from = que.<span class="built_in">top</span>().from;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[from])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[from] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : edges[from])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edge.to, weight = edge.weight;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; dis[from] + weight)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = dis[from] + weight;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; bridges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        bridges.<span class="built_in">push_back</span>(&#123;u, v, w&#125;);</span><br><span class="line">        edges[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        edges[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res_dis</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(n, i);</span><br><span class="line">        res_dis[i] = dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : vec)</span><br><span class="line">            cin &gt;&gt; v;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> dfs, <span class="type">int</span> cur, <span class="type">int</span> i, <span class="type">int</span> sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == k)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, sum + res_dis[cur][n]);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [u, v, w] = bridges[vec[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, v, i + <span class="number">1</span>, sum + res_dis[cur][u] + w);</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, u, i + <span class="number">1</span>, sum + res_dis[cur][v] + w);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(<span class="built_in">all</span>(vec)));</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 370 题解</title>
    <url>/2024-09-08-atcoder-abc-370.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,3202nd,Solved ABC,+22</p>
<p>因为博主太困所以打算等下周空闲时间把这场和上场的题意补上。[TODO]</p>
<span id="more"></span>

<h1 id="A-Raise-Both-Hands"><a href="#A-Raise-Both-Hands" class="headerlink" title="A.Raise Both Hands"></a>A.Raise Both Hands</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>打表（这能叫做一个表吗？）即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">if</span> (l &amp;&amp; !r)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!l &amp;&amp; r)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-Binary-Alchemy"><a href="#B-Binary-Alchemy" class="headerlink" title="B.Binary Alchemy"></a>B.Binary Alchemy</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>按规则模拟即可，为了缩减代码量我直接采用了 <code>max</code> 和 <code>min</code> 来替代一层 <code>if</code> 判断，增加的复杂度无伤大雅。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">    <span class="type">int</span> element = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ele = <span class="number">1</span>; ele &lt;= n; ele++)</span><br><span class="line">        element = vec[<span class="built_in">max</span>(element, ele)][<span class="built_in">min</span>(ele, element)];</span><br><span class="line">    cout &lt;&lt; element &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Word-Ladder"><a href="#C-Word-Ladder" class="headerlink" title="C.Word Ladder"></a>C.Word Ladder</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>显然，因为修改本身没有限制，所以最少的修改次数必然是两个字符串不同字符的字符个数。</p>
<p>下面考虑如何让每次修改字典序最小。</p>
<p>显而易见，将一个字典序大的字符修改为一个字典序小的字符，字符串的整体字典序会下降，反之上升。而字典序的比较规则是从前往后比较，即为前面的字典序下降对整体字符串字典序的影响更大，而后面字符字典序上升对整体字符串字典序影响更小。</p>
<p>所以，为了让每次修改后的字典序是最优，我们首先正序修改会导致字典序下降的字符，让字典序“速降”，再倒序修改会导致字典序上升的字符，让字典序“缓升”。这样的解法就是最优的。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; inc,dec;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; t[i])</span><br><span class="line">            inc.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt; t[i])</span><br><span class="line">            dec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : dec)</span><br><span class="line">        s[v] = t[v], ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(inc));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : inc)</span><br><span class="line">        s[v] = t[v], ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : ans)</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分。</strong></p>
<h1 id="D-Cross-Explosion"><a href="#D-Cross-Explosion" class="headerlink" title="D.Cross Explosion"></a>D.Cross Explosion</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><h3 id="朴素的暴力"><a href="#朴素的暴力" class="headerlink" title="朴素的暴力"></a>朴素的暴力</h3><p>直接根据题意暴力即可，开启O3优化后，对于本题会TLE两个点，但是大部分样例都能过，证明只要在暴力上进行优化即可。</p>
<h3 id="暴力的优化"><a href="#暴力的优化" class="headerlink" title="暴力的优化"></a>暴力的优化</h3><p>暴力的优化一共有两个方向，一种是用数组维护当前节点的相邻节点，另外一种是 <code>set</code> 记录目前剩余节点并二分查找相邻节点。</p>
<p>我赛时写的第一种优化，没优化出来。</p>
<p>但这种优化好像有些边界条件模糊，还真不如二分set好懂，于是干脆只写二分set了。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">// set + 二分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, q;</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; w &gt;&gt; q;</span><br><span class="line">    vector&lt;set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">col</span>(w + <span class="number">1</span>), <span class="built_in">row</span>(h + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">            row[i].<span class="built_in">insert</span>(j), col[j].<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        row[i].<span class="built_in">insert</span>(<span class="number">0</span>), row[i].<span class="built_in">insert</span>(w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)</span><br><span class="line">        col[i].<span class="built_in">insert</span>(<span class="number">0</span>), col[i].<span class="built_in">insert</span>(h + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = h * w;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">auto</span> it = row[x].<span class="built_in">lower_bound</span>(y), it2 = <span class="built_in">prev</span>(it); <span class="comment">// 搜行</span></span><br><span class="line">        <span class="keyword">if</span> (*it == y) <span class="comment">// 只炸自己</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans--, row[x].<span class="built_in">erase</span>(y), col[y].<span class="built_in">erase</span>(x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*it &lt;= w) <span class="comment">// 搜索到的it不到边界</span></span><br><span class="line">            ans--, row[x].<span class="built_in">erase</span>(*it), col[*it].<span class="built_in">erase</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (*it2) <span class="comment">// it的前一个不到边界</span></span><br><span class="line">            ans--, row[x].<span class="built_in">erase</span>(*it2), col[*it2].<span class="built_in">erase</span>(x);</span><br><span class="line">        it = col[y].<span class="built_in">lower_bound</span>(x), it2 = <span class="built_in">prev</span>(it); <span class="comment">// 搜列</span></span><br><span class="line">        <span class="keyword">if</span> (*it &lt;= h)</span><br><span class="line">            ans--, row[*it].<span class="built_in">erase</span>(y), col[y].<span class="built_in">erase</span>(*it);</span><br><span class="line">        <span class="keyword">if</span> (*it2)</span><br><span class="line">            ans--, row[*it2].<span class="built_in">erase</span>(y), col[y].<span class="built_in">erase</span>(*it2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Avoid-K-Partition"><a href="#E-Avoid-K-Partition" class="headerlink" title="E.Avoid K Partition"></a>E.Avoid K Partition</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><h3 id="时间复杂度-O-N-2"><a href="#时间复杂度-O-N-2" class="headerlink" title="时间复杂度 $O(N^2)$"></a>时间复杂度 $O(N^2)$</h3><p>二维 <code>dp</code>，定义 $dp[i]$ 为在选定点 $i$ 的时候，从 $1$ 选到 $i$ 的方案的总和。</p>
<p>初始值： $dp[1] &#x3D; 1$ ，终值取  $dp[n+1]$ ，过程中的推导式为 $dp[n] &#x3D; \sum_{1 \leq m \lt n} \left(0\text{ if }\sum_{k&#x3D;m}^{n-1} A_i &#x3D; K \text{ else } dp[m] \right) $。</p>
<p>注意：虽然这个式子中的$\sum A_i$部分可以用前缀和，但是时间复杂度最坏是$N^2$，这个推导式过不了本题目，要对其进行优化。</p>
<h3 id="优化正解"><a href="#优化正解" class="headerlink" title="优化正解"></a>优化正解</h3><p>可以发现转移只会从 $\sum^i_j {A_i \neq k}$ 的区间来，所以分别记录目前的总方案数和上述区间的方案数，则 $dp[i] &#x3D; sum-invalid$。</p>
<p>开一个 <code>map</code> 进行缓存，令 $mp[pref]$ 等价前缀和为 $pref$ 时的合法方案数，则 $invalid &#x3D; mp[sum-k]$。答案得以求出。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    i64 k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    map&lt;i64, <span class="type">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    i64 sum = <span class="number">0</span>, all = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += vec[i];</span><br><span class="line">        <span class="type">int</span> invalid = mp[sum - k];</span><br><span class="line">        dp[i] = (all - invalid + MOD) % MOD;</span><br><span class="line">        all = (all + dp[i]) % MOD;</span><br><span class="line">        mp[sum] = (mp[sum] + dp[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Beginner Contest 372 题解</title>
    <url>/2024-09-22-atcoder-abc-372.html</url>
    <content><![CDATA[<p>竞赛结果：Contestant,3675th,-2。</p>
<span id="more"></span>

<h1 id="A-Delete"><a href="#A-Delete" class="headerlink" title="A.Delete ."></a>A.Delete .</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串，非’.’输出即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : str)</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="B-3-A"><a href="#B-3-A" class="headerlink" title="B.3^A"></a>B.3^A</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>从高到低枚举pow(3,i)是否小于等于n，是则相减，易得构造出来的数列一定在20个以内。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (m)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">pow</span>(<span class="number">3</span>, i) &lt;= m)</span><br><span class="line">                m -= <span class="built_in">pow</span>(<span class="number">3</span>, i),ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : ans)</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-Count-ABC-Again"><a href="#C-Count-ABC-Again" class="headerlink" title="C.Count ABC Again"></a>C.Count ABC Again</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>单个字符的修改最多会影响其字符-3到字符+3位置的ABC的数量，预处理后每次查询小规模暴力即可。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; str[i + <span class="number">2</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            pos.<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; idx &gt;&gt; ch;</span><br><span class="line">        idx--;</span><br><span class="line">        str[idx] = ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">0</span>, idx - <span class="number">4</span>); i &lt;= <span class="built_in">min</span>(n - <span class="number">3</span>, idx + <span class="number">4</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos.<span class="built_in">find</span>(i) != pos.<span class="built_in">end</span>() &amp;&amp; !(str[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; str[i + <span class="number">2</span>] == <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">                pos.<span class="built_in">erase</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (pos.<span class="built_in">find</span>(i) == pos.<span class="built_in">end</span>() &amp;&amp; (str[i] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; str[i + <span class="number">2</span>] == <span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">                pos.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; pos.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以下为补题部分。</strong></p>
<h1 id="D-Buildings"><a href="#D-Buildings" class="headerlink" title="D.Buildings"></a>D.Buildings</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>$O(N^2)$ 的暴力好实现，主要是如何优化时间复杂度使得答案不会TLE。</p>
<p>使用单调栈数据结构可以做到这点。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hs;</span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(&#123;INT_MAX, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hs.second = i;</span><br><span class="line">        cin &gt;&gt; hs.first;</span><br><span class="line">        <span class="keyword">while</span> (st.<span class="built_in">top</span>().first &lt;= hs.first)</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        ans[st.<span class="built_in">top</span>().second]++;</span><br><span class="line">        ans[hs.second]--;</span><br><span class="line">        st.<span class="built_in">push</span>(hs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] + ans[i];</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="E-K-th-Largest-Connected-Components"><a href="#E-K-th-Largest-Connected-Components" class="headerlink" title="E.K-th Largest Connected Components"></a>E.K-th Largest Connected Components</h1><p>并查集维护每个节点的父节点，在父节点处维护前10大的子节点即可。</p>
<p>因为一开始没注意到 $k&#x3D;10 $ 所以TLE了好几发。赛后才过的。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">size_t</span>&gt; pa, size;</span><br><span class="line">    map&lt;<span class="type">size_t</span>, vector&lt;<span class="type">size_t</span>&gt;&gt; components;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">dsu</span><span class="params">(<span class="type">size_t</span> size_)</span> : pa(size_), size(size_, <span class="number">1</span>)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">iota</span>(pa.<span class="built_in">begin</span>(), pa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size_; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            components[i] = &#123;i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">size_t</span> x)</span> </span>&#123; <span class="keyword">return</span> pa[x] == x ? x : pa[x] = <span class="built_in">find</span>(pa[x]); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">size_t</span> x, <span class="type">size_t</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        pa[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(components[x]), greater&lt;&gt;());</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(components[y]), greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(<span class="number">10</span>, (<span class="type">int</span>)components[x].<span class="built_in">size</span>()); i++)</span><br><span class="line">            n.<span class="built_in">push_back</span>(components[x][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(<span class="number">10</span>, (<span class="type">int</span>)components[y].<span class="built_in">size</span>()); i++)</span><br><span class="line">            n.<span class="built_in">push_back</span>(components[y][i]);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(n), greater&lt;&gt;());</span><br><span class="line">        components[x].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>((<span class="type">int</span>)n.<span class="built_in">size</span>(), <span class="number">10</span>); i++)</span><br><span class="line">            components[x].<span class="built_in">push_back</span>(n[i]);</span><br><span class="line">        components.<span class="built_in">erase</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">connected</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">dsu <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (op &amp; <span class="number">1</span>)</span><br><span class="line">            d.<span class="built_in">unite</span>(a, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector res = d.<span class="built_in">connected</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() &gt;= b)</span><br><span class="line">                cout &lt;&lt; res[b - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>ACM</tag>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
</search>
